[
    {
        "author": "Phaticusthiccy",
        "pluginName": "Thena Image Generation",
        "keywords": [
            "image",
            "generation",
            "ai",
            "image generation"
        ],
        "pluginId": "image-generation",
        "description": "Generate images using Thena API",
        "downloads": 23,
        "pluginVersion": "1.0.8",
        "pluginFileName": "image_gen.js",
        "context": "var axios = require('axios');\r\nvar fs = require('fs');\r\n\r\nvar runningProcesses = [];\r\nsetInterval(async () => {\r\n    if (runningProcesses.length > 0) {\r\n        var index = 0;\r\n        while (index < runningProcesses.length) {\r\n            index++\r\n            var getGenerationStatus = await axios.get(runningProcesses[index - 1].url);\r\n\r\n\r\n            if (getGenerationStatus.data.status == 200) {\r\n                const tempProcess = runningProcesses\r\n                runningProcesses = runningProcesses.filter(x => x.url != tempProcess[index - 1].url);\r\n\r\n                var mediaPath = \".\/src\/Thena\" + Math.floor(Math.random() * 100) + \".png\";\r\n                fs.writeFileSync(mediaPath, getGenerationStatus.data.image, 'base64');\r\n\r\n                try { await tempProcess[index - 1].sock.sendMessage(tempProcess[index - 1].msg, { delete: tempProcess[index - 1].messageId }) } catch { }\r\n                try { await tempProcess[index - 1].sock.sendMessage(tempProcess[index - 1].msg, { image: { url: mediaPath }, caption: tempProcess[index - 1].caption }) } catch {\r\n                    try {\r\n                        await tempProcess[index - 1].sock.sendMessage(tempProcess[index - 1].msg, { image: { url: mediaPath }, caption: \"*‚ú® Image generated by Thena AI*\" })\r\n                    } catch {\r\n                    }\r\n                }\r\n\r\n                try { fs.unlinkSync(mediaPath) } catch { }\r\n            } else {\r\n                if (getGenerationStatus.data.status != 202) {\r\n                    const tempProcess = runningProcesses\r\n                    runningProcesses = runningProcesses.filter(x => x.url != tempProcess[index - 1].url);\r\n                    try { await tempProcess[index - 1].sock.sendMessage(tempProcess[index - 1].msg, { delete: tempProcess[index - 1].messageId }) } catch { }\r\n                    await tempProcess[index - 1].sock.sendMessage(tempProcess[index - 1].msg, { text: \"_‚ùå Generation failed!_\" });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}, 8000)\r\n\r\naddCommand({ pattern: \"^dream ?(.*)\", access: \"all\", desc: \"_Generate an image using Thena API._\", usage: global.handlers[0] + \"dream <text> <model> <ratio> <mode>\", pluginVersion: \"1.0.8\", pluginId: \"image-generation\" }, async (msg, match, sock, rawMessage) => {\r\n    if (!global.database.thenaAPIKey && !String(match[1]).includes(\"addAPI\")) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg, { text: \"_üîê You need to set your Thena API Key first._\\n\\n_Use_ ```\" + global.handlers[0] + \"dream addAPI <your-api-key>``` _to set it._\\n\\n_To obtain API Key, please visit here: https:\/\/t.me\/ThenaAIBot?start=refAPI_\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg, { text: \"_‚ùå The bot owner hasn't added an API key to use this command! Please contact the bot owner._\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    var text = match[1];\r\n    if (!text) {\r\n        return await sock.sendMessage(msg, { text: \"_üî§ You need to provide a text to generate an image._\\n\\n_Example ::_ ```\" + global.handlers[0] + \"dream <text> <model> <ratio> <mode>```\" + \"\\n\\n_Models ::_ ```-real || -movie || -anime```\\n_Ratio ::_ ```1:1 || 3:4 || 9:16 || 4:3 || 16:9```\\n_Mode ::_ ```-fast || -quality```\", edit: msg.key }, { quoted: rawMessage.messages[0] });\r\n    };\r\n\r\n    if (text.includes(\"addAPI\") && msg.key.fromMe) {\r\n        const apiKey = match[1].replace(\"addAPI \", \"\").replace(\/ \/gmi, \"\");\r\n        if (!apiKey) {\r\n            return await sock.sendMessage(msg, { text: \"_‚ùå You need to provide an API key to add._\\n\\n_Use_ ```\" + global.handlers[0] + \"dream addAPI <your-api-key>``` _to add it._\\n\\n_To obtain API Key, please visit here: https:\/\/t.me\/ThenaAIBot?start=refAPI_\", edit: msg.key });\r\n        }\r\n        global.database.thenaAPIKey = apiKey;\r\n        return await sock.sendMessage(msg, { text: \"_‚úÖ API key added successfully._\", edit: msg.key });\r\n    }\r\n\r\n    const model = match[1].includes(\"-real\") ? \"real\" : (match[1].includes(\"-movie\") ? \"movie\" : (match[1].includes(\"-anime\") ? \"anime\" : \"real\"));\r\n    const ratio = match[1].includes(\"3:4\") ? \"3:4\" : (match[1].includes(\"9:16\") ? \"9:16\" : (match[1].includes(\"4:3\") ? \"4:3\" : (match[1].includes(\"16:9\") ? \"16:9\" : \"1:1\")));\r\n    const mode = match[1].includes(\"-fast\") ? \"fast\" : \"quality\";\r\n\r\n    var modelText = model == \"real\" ? \"Photoreal\" : (model == \"movie\" ? \"Movie\" : \"Anime\");\r\n    const ratioMapping = {\r\n        \"1:1\": { width: 1024, height: 1024 },\r\n        \"3:4\": { width: 768, height: 1024 },\r\n        \"9:16\": { width: 576, height: 1024 },\r\n        \"4:3\": { width: 1024, height: 768 },\r\n        \"16:9\": { width: 1024, height: 576 }\r\n    }\r\n\r\n    const dimensions = ratioMapping[ratio] || { width: 1024, height: 1024 }\r\n    const tempGroupId = msg.key.remoteJid;\r\n\r\n    const payload = {\r\n        \"prompt\": text.replace(model, \"\").replace(ratio, \"\"),\r\n        \"model\": model === \"real\" ? \"754019 b5df2e e606f1 a7600b 96b0c8 94\" : model === \"movie\" ? \"8gg12 61812 6628 19729 6b4a5 5060\" : model === \"anime\" ? \"5g72h1 y661hp k771ns 33bb21 77bagl 6b 3090\" : \"754019 b5df2e e606f1 a7600b 96b0c8 94\",\r\n        \"creative\": false,\r\n        \"width\": dimensions.width,\r\n        \"height\": dimensions.height,\r\n        \"fastMode\": mode === \"fast\" ? true : false,\r\n        \"enhance\": true\r\n    }\r\n    var payloadConfig = {\r\n        method: 'post',\r\n        url: 'https:\/\/create.thena.workers.dev\/create_image_thena_v5',\r\n        headers: {\r\n            'User-Agent': global.database.thenaAPIKey,\r\n            'Content-Type': 'application\/json'\r\n        },\r\n        data: payload\r\n    };\r\n\r\n    var result = await axios(payloadConfig);\r\n\r\n    if (result.data.status == 200) {\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg, { text: \"_üîÑÔ∏è Image generating.._\", edit: msg.key });\r\n        } else {\r\n            var publicMessage = await sock.sendMessage(msg, { text: \"_üîÑÔ∏è Image generating.._\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n\r\n        runningProcesses.push({\r\n            url: \"https:\/\/create.thena.workers.dev\/status?id=\" + result.data.image,\r\n            messageId: msg.key.fromMe ? msg.key : publicMessage.key,\r\n            groupId: tempGroupId,\r\n            msg: msg,\r\n            caption: \"*‚ú® Image generated by Thena AI*\\n\\n_Model ::_ ```\" + modelText + \"```\" + \"\\n_Prompt ::_ ```\" + text + \"```\",\r\n            sock: sock,\r\n        })\r\n        return;\r\n    } else {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg, { text: \"_‚ùå Failed to generate image._\\n\\n_Error: \" + result.data.content + \"_\\n\\n_Please try again later._\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg, { text: \"_‚ùå Failed to generate image._\\n\\n_Error: \" + result.data.content + \"_\\n\\n_Please try again later._\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n})",
        "usage": "menu dream",
        "videoPath": ".\/src\/thena.mp4"
    },
    {
        "author": "lc3zy",
        "pluginName": "Blackjack",
        "keywords": [
            "card game",
            "card",
            "blackjack"
        ],
        "usage": "menu blackjack",
        "pluginId": "blackjack",
        "description": "A simple blackjack game",
        "downloads": 44,
        "pluginVersion": "1.0.3",
        "pluginFileName": "blackjack.js",
        "context": "function createDeck() {\r\n    const suits = [\"‚ù§Ô∏è\", \"‚ô¶Ô∏è\", \"‚ô£Ô∏è\", \"‚ô†Ô∏è\"];\r\n    const ranks = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\"];\r\n    let deck = [];\r\n\r\n    for (let suit of suits) {\r\n        for (let rank of ranks) {\r\n            deck.push({ suit, rank });\r\n        }\r\n    }\r\n    return deck;\r\n}\r\n\r\nfunction shuffle(deck) {\r\n    for (let i = deck.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [deck[i], deck[j]] = [deck[j], deck[i]];\r\n    }\r\n    return deck;\r\n}\r\n\r\nfunction dealCard(deck) {\r\n    let card = deck.pop();\r\n    return card;\r\n}\r\n\r\nfunction cardValue(card) {\r\n    if ([\"J\", \"Q\", \"K\"].includes(card.rank)) return 10;\r\n    if (card.rank === \"A\") return 11; \/\/ Ace starts as 11\r\n    return parseInt(card.rank, 10);\r\n}\r\n\r\nfunction calculateHandValue(hand) {\r\n    let total = 0;\r\n    let aces = 0;\r\n\r\n    for (let card of hand) {\r\n        total += cardValue(card);\r\n        if (card.rank === \"A\") aces++;\r\n    }\r\n\r\n    while (total > 21 && aces > 0) {\r\n        total -= 10;\r\n        aces--;\r\n    }\r\n    return total;\r\n}\r\n\r\nfunction displayHand(hand) {\r\n    return hand.map(card => `${card.suit} ${card.rank} `).join(\", \");\r\n}\r\n\r\nasync function sendMsg(groupId, msg, sock, rawMessage, text) {\r\n    let key = database.games.blackjack[msg.key.remoteJid]?.msgkey;\r\n\r\n    if (key && !database.games.blackjack[msg.key.remoteJid].newMsg) {\r\n        return await sock.sendMessage(groupId, { text, edit: key });\r\n    } else {\r\n        return await sock.sendMessage(groupId, { text, quoted: rawMessage.messages[0] });\r\n    }\r\n}\r\n\r\nasync function updateGameState(gameState, groupId, msg, sock, rawMessage) {\r\n    let message = `üÉè *Your hand:* ${displayHand(gameState.playerHand)} (Total: ${gameState.playerTotal})\\n`;\r\n    message += `üé© *Dealer shows:* ${displayHand([gameState.dealerHand[0]])} ?\\n`;\r\n\r\n    if (gameState.isPlayerTurn) {\r\n        message += \"ü§î What's your move? Type *'hit'* to draw a card or *'stand'* to hold your position.\";\r\n    }\r\n\r\n    const pbl = await sendMsg(groupId, msg, sock, rawMessage, message);\r\n\r\n    if (!global.database.games.blackjack[msg.key.remoteJid].msgkey) {\r\n        global.database.games.blackjack[groupId].messageId = pbl.key.id;\r\n        global.database.games.blackjack[groupId].msgkey = pbl.key;\r\n    }\r\n}\r\n\r\naddCommand({ pattern: \"^blackjack$\", access: \"all\", desc: \"Start a game of Blackjack!\", pluginVersion: \"1.0.3\", pluginId: \"blackjack\" }, async (msg, match, sock, rawMessage) => {    \r\n    const groupId = msg.key.remoteJid;\r\n    const playerId = msg.key.fromMe ? sock.user.id.split(':')[0] + \"@s.whatsapp.net\" : (msg.key.participant ? msg.key.participant : msg.key.remoteJid);\r\n\r\n    if (!global.database.games) global.database.games = {};\r\n    if (!global.database.games.blackjack) global.database.games.blackjack = {};\r\n\r\n    if (!global.database.games.blackjack[groupId]) {\r\n        const deck = shuffle(createDeck());\r\n        const playerHand = [dealCard(deck), dealCard(deck)];\r\n        const dealerHand = [dealCard(deck), dealCard(deck)];\r\n\r\n        global.database.games.blackjack[groupId] = {\r\n            player: playerId,\r\n            remoteJid: msg.key.remoteJid,\r\n            deck,\r\n            playerHand,\r\n            dealerHand,\r\n            playerTotal: calculateHandValue(playerHand),\r\n            dealerTotal: calculateHandValue(dealerHand),\r\n            isPlayerTurn: true,\r\n            isGameOver: false,\r\n            msgkey: undefined,\r\n            newMsg: false,\r\n        };\r\n    }\r\n\r\n    const gameState = global.database.games.blackjack[groupId];\r\n    await updateGameState(gameState, groupId, msg, sock, rawMessage);\r\n});\r\n\r\naddCommand({ pattern: \"onMessage\", access: \"all\", dontAddCommandList: true }, async (msg, match, sock, rawMessage) => {\r\n    const groupId = msg.key.remoteJid;\r\n    const currentPlayerId = msg.key.fromMe ? sock.user.id.split(':')[0] + \"@s.whatsapp.net\" : (msg.key.participant ? msg.key.participant : msg.key.remoteJid);\r\n\r\n    if (global.database?.games?.blackjack[groupId] && global.database.games.blackjack[groupId].player !== currentPlayerId && !msg.key.fromMe) {\r\n        global.database.games.blackjack[groupId].newMsg = true;\r\n    }\r\n\r\n    if (global.database?.games?.blackjack[groupId] && global.database.games.blackjack[groupId].player === currentPlayerId) {\r\n        const gameState = global.database.games.blackjack[groupId];\r\n\r\n        if (!gameState.isGameOver) {\r\n            const action = msg.text.trim().toLowerCase();\r\n\r\n            if ([\"hit\", \"stand\"].includes(action)) {\r\n\r\n                const handlePlayerAction = async (action) => {\r\n                    if (action === \"hit\") {\r\n                        const card = dealCard(gameState.deck);\r\n                        gameState.playerHand.push(card);\r\n                        gameState.playerTotal = calculateHandValue(gameState.playerHand);\r\n\r\n                        await sendMsg(groupId, msg, sock, rawMessage, \r\n                            `üé¥ You drew: ${card.rank} of ${card.suit}\\nüÉè *Your hand:* ${displayHand(gameState.playerHand)} (Total: ${gameState.playerTotal})`);\r\n\r\n                        if (gameState.playerTotal > 21) {\r\n                            gameState.isGameOver = true;\r\n                            await sendMsg(groupId, msg, sock, rawMessage, \r\n                                `üé≠ *Dealer's hand:* ${displayHand(gameState.dealerHand)} (Total: ${gameState.dealerTotal})\\n üÉè *Your hand:* ${displayHand(gameState.playerHand)} (Total: ${gameState.playerTotal})\\nüí• Bust! You went over 21. Dealer wins.`);\r\n                            delete global.database.games.blackjack[groupId];\r\n                            return;\r\n                        }\r\n                    } else if (action === \"stand\") {\r\n                        gameState.isPlayerTurn = false;\r\n                    }\r\n\r\n                    await updateGameState(gameState, groupId, msg, sock, rawMessage);\r\n                };\r\n\r\n                await handlePlayerAction(action);\r\n\r\n                if (!gameState.isPlayerTurn && !gameState.isGameOver) {\r\n                    const handleDealerTurn = async () => {\r\n                        while (calculateHandValue(gameState.dealerHand) < 17) {\r\n                            const card = dealCard(gameState.deck);\r\n                            gameState.dealerHand.push(card);\r\n                            gameState.dealerTotal = calculateHandValue(gameState.dealerHand);\r\n                        }\r\n                        gameState.isGameOver = true;\r\n\r\n                        let message = `üé≠ *Dealer's hand:* ${displayHand(gameState.dealerHand)} (Total: ${gameState.dealerTotal})\\n üÉè *Your hand:* ${displayHand(gameState.playerHand)} (Total: ${gameState.playerTotal})`;\r\n                        if (gameState.dealerTotal > 21) {\r\n                            message += \"üöÄ Dealer busts! You win! üéâ\";\r\n                        } else if (gameState.dealerTotal > gameState.playerTotal) {\r\n                            message += \"üèÜ Dealer wins!\";\r\n                        } else if (gameState.dealerTotal < gameState.playerTotal) {\r\n                            message += \"üéä You win!\";\r\n                        } else {\r\n                            message += \"ü§ù It's a tie!\";\r\n                        }\r\n                        await sendMsg(groupId, msg, sock, rawMessage, message);\r\n                        delete global.database.games.blackjack[groupId];\r\n                    };\r\n                    await handleDealerTurn();\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\n",
        "videoPath": ".\/src\/bj.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "ChatGPT",
        "keywords": [
            "chatgpt",
            "o3",
            "ai",
            "openai",
            "chat",
            "gpt",
            "chatbot"
        ],
        "usage": "menu chatgpt",
        "pluginId": "o3gpt",
        "description": "Start a ChatGPT (o3) session!",
        "downloads": 34,
        "pluginVersion": "1.1.3",
        "pluginFileName": "o3session.js",
        "context": "const axios = require(\"axios\");\r\n\r\naddCommand({ pattern: \"^chatgpt ?(.*)\", access: \"sudo\", desc: \"Start a ChatGPT (o3) session!\", pluginVersion: \"1.1.3\", pluginId: \"o3gpt\" }, async (msg, match, sock, rawMessage) => {\r\n    const groupId = msg.key.remoteJid;\r\n    if (!global.database.o3mini) global.database.o3mini = [];\r\n    var findO3SessioninDb = global.database.o3mini.find(session => session.groupId == groupId);\r\n    var findGlobalO3Config = global.database?.o3miniConfigs\r\n    if (!findGlobalO3Config) {\r\n        global.database.o3miniConfigs = {\r\n            onlyGroup: false,\r\n            onlyPrivate: false,\r\n            lockAllChats: false,\r\n            generalSystemPrompt: \"\",\r\n        }\r\n    }\r\n    if (!findO3SessioninDb) {\r\n        global.database.o3mini.push({\r\n            groupId: groupId,\r\n            totalMessages: 0,\r\n            systemPrompt: \"\",\r\n            active: false,\r\n        });\r\n        findO3SessioninDb = global.database.o3mini.find(session => session.groupId == groupId);\r\n    }\r\n    var argument = match[1];\r\n    if (!argument) {\r\n        var text = `ü§ñ *GPT o3*\\n\\n` +\r\n            (findO3SessioninDb.active ? \"_System Prompt:_ \" + findO3SessioninDb.systemPrompt + \"\\n\" : \"_System Prompt: Using Defaults_\\n\") +\r\n            (findO3SessioninDb.active ? \"_Total Messages:_ \" + findO3SessioninDb.totalMessages + \"\\n\" : \"\") +\r\n            (findO3SessioninDb.active ? \"_üü¢ AI Chat is active in this group!_\\n\\n\" : \"_üî¥ AI Chat is inactive in this group!_\\n\\n\") +\r\n            \"_Type_ `chatgpt <on || off>` _to activate AI Chat in this group._\\n\" +\r\n            \"_Type_ `chatgpt sys <system prompt>` _to set system prompt for AI Chat in this group._\\n\" +\r\n            \"_Type_ `chatgpt global` _to change settings for AI Chat in all groups._\"\r\n\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(groupId, { text: text, edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(groupId, { text: text }, { quoted: rawMessage.messages[0] });\r\n        }\r\n    } else {\r\n        argument = argument.toLowerCase().trimStart();\r\n        if (argument == \"on\") {\r\n            findO3SessioninDb.active = true;\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(groupId, { text: \"_üü¢ AI Chat is active in this group!_\", edit: msg.key });\r\n            } else {\r\n                return await sock.sendMessage(groupId, { text: \"_üü¢ AI Chat is active in this group!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        } else if (argument == \"off\") {\r\n            findO3SessioninDb.active = false;\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(groupId, { text: \"_üî¥ AI Chat is inactive in this group!_\", edit: msg.key });\r\n            } else {\r\n                return await sock.sendMessage(groupId, { text: \"_üî¥ AI Chat is inactive in this group!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n        if (argument.startsWith(\"sys \")) {\r\n            var systemPrompt = argument.replace(\"sys \", \"\");\r\n            findO3SessioninDb.systemPrompt = systemPrompt;\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(groupId, { text: \"_‚úÖ System Prompt has been set to: \" + systemPrompt + \"_\", edit: msg.key });\r\n            } else {\r\n                return await sock.sendMessage(groupId, { text: \"_‚úÖ System Prompt has been set to: \" + systemPrompt + \"_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n        if (argument == \"global\") {\r\n            var text = `ü§ñ *GPT o3*\\n\\n` +\r\n                (global.database.o3miniConfigs.onlyGroup ? \"_üü¢ Only Group Chat is active in all groups!_\\n\" : \"_üî¥ Only Group Chat is inactive in all groups!_\\n\") +\r\n                (global.database.o3miniConfigs.onlyPrivate ? \"_üü¢ Only Private Chat is active in all groups!_\\n\" : \"_üî¥ Only Private Chat is inactive in all groups!_\\n\") +\r\n                (global.database.o3miniConfigs.lockAllChats ? \"_üü¢ All Chats are locked in all groups!_\\n\" : \"_üî¥ All Chats are unlocked in all groups!_\\n\") +\r\n                (global.database.o3miniConfigs?.generalSystemPrompt !== \"\" ? \"_‚úÖ General System Prompt is set to: \" + global.database.o3miniConfigs.generalSystemPrompt + \"_\\n\" : \"_‚ùå General System Prompt is not set in all groups!_\\n\") +\r\n                \"\\n_Type_ `chatgpt global <on || off>` _to activate\/deactivate Only Group Chat in all groups._\\n\" +\r\n                \"_Type_ `chatgpt global private <on || off>` _to activate\/deactivate Only Private Chat in all groups._\\n\" +\r\n                \"_Type_ `chatgpt global lock <on || off>` _to activate\/deactivate All Chats in all groups._\\n\" +\r\n                \"_Type_ `chatgpt global sys <system prompt>` _to set general system prompt for all groups._\\n\" +\r\n                \"_Type_ `chatgpt global sys off` _to remove general system prompt from all groups._\"\r\n\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(groupId, { text: text, edit: msg.key });\r\n            } else {\r\n                return await sock.sendMessage(groupId, { text: text }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n        if (argument.startsWith(\"global\")) {\r\n            var argument = argument.replace(\"global\", \"\").trimStart();\r\n            if (argument.startsWith(\"on\")) {\r\n                var oldprivate = global.database.o3miniConfigs.onlyPrivate;\r\n                global.database.o3miniConfigs.onlyGroup = true;\r\n                global.database.o3miniConfigs.onlyPrivate = false;\r\n                \r\n                var extramsg = \"\";\r\n                if (oldprivate == true && global.database.o3miniConfigs.onlyPrivate == false) extramsg = \"\\n_üî¥ Only Private Chat has been disabled!_\";\r\n                \r\n                if (msg.key.fromMe) {\r\n                    return await sock.sendMessage(groupId, { text: \"_üü¢ Only Group Chat is active in all groups!_\" + extramsg, edit: msg.key });\r\n                } else {\r\n                    return await sock.sendMessage(groupId, { text: \"_üü¢ Only Group Chat is active in all groups!_\" + extramsg }, { quoted: rawMessage.messages[0] });\r\n                }\r\n            } else if (argument.startsWith(\"off\")) {\r\n                global.database.o3miniConfigs.onlyGroup = false;\r\n                if (msg.key.fromMe) {\r\n                    return await sock.sendMessage(groupId, { text: \"_üî¥ Only Group Chat is inactive in all groups!_\", edit: msg.key });\r\n                } else {\r\n                    return await sock.sendMessage(groupId, { text: \"_üî¥ Only Group Chat is inactive in all groups!_\" }, { quoted: rawMessage.messages[0] });\r\n                }\r\n            }\r\n            if (argument.startsWith(\"private\")) {\r\n                var onOffStatus  = String(argument.split(\"private\")[1]).trimStart().toLowerCase();\r\n\r\n                if (onOffStatus == \"on\") {\r\n                    var oldgroup = global.database.o3miniConfigs.onlyGroup;\r\n                    global.database.o3miniConfigs.onlyGroup = false;\r\n                    global.database.o3miniConfigs.onlyPrivate = true;\r\n\r\n                    var extramsg = \"\";\r\n                    if (oldgroup == true && global.database.o3miniConfigs.onlyGroup == false) extramsg = \"\\n_üî¥ Only Group Chat has been disabled!_\";\r\n\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_üü¢ Only Private Chat is active in all groups!_\" + extramsg, edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_üü¢ Only Private Chat is active in all groups!_\" + extramsg }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                } else if (onOffStatus == \"off\") {\r\n                    global.database.o3miniConfigs.onlyPrivate = false;\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_üî¥ Only Private Chat is inactive in all groups!_\", edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_üî¥ Only Private Chat is inactive in all groups!_\" }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                } else {\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_‚ùå Invalid argument! Please use `on` or `off` as argument._\", edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_‚ùå Invalid argument! Please use `on` or `off` as argument._\" }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                }\r\n            }\r\n            if (argument.startsWith(\"lock\")) {\r\n                var onOffStatus  = String(argument.split(\"lock\")[1]).trimStart().toLowerCase();\r\n                \r\n                if (onOffStatus == \"on\") {\r\n                    global.database.o3miniConfigs.lockAllChats = true;\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_üü¢ All Chats are locked in all groups!_\", edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_üü¢ All Chats are locked in all groups!_\" }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                } else if (onOffStatus == \"off\") {\r\n                    global.database.o3miniConfigs.lockAllChats = false;\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_üî¥ All Chats are unlocked in all groups!_\", edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_üî¥ All Chats are unlocked in all groups!_\" }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                } else {\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_‚ùå Invalid argument! Please use `on` or `off` as argument._\", edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_‚ùå Invalid argument! Please use `on` or `off` as argument._\" }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                }\r\n            }\r\n            if (argument.startsWith(\"sys\")) {\r\n                var onOffStatusOrSystemPrompt  = String(argument.split(\"sys\")[1]).trimStart().toLowerCase();\r\n                \r\n                if (onOffStatusOrSystemPrompt == \"off\") {\r\n                    global.database.o3miniConfigs.generalSystemPrompt = \"\";\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_üî¥ System Prompt has been removed from all groups!_\", edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_üî¥ System Prompt has been removed from all groups!_\" }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                } else {\r\n                    global.database.o3miniConfigs.generalSystemPrompt = onOffStatusOrSystemPrompt;\r\n                    if (msg.key.fromMe) {\r\n                        return await sock.sendMessage(groupId, { text: \"_‚úÖ System Prompt has been set to: \" + onOffStatusOrSystemPrompt + \"_\", edit: msg.key });\r\n                    } else {\r\n                        return await sock.sendMessage(groupId, { text: \"_‚úÖ System Prompt has been set to: \" + onOffStatusOrSystemPrompt + \"_\" }, { quoted: rawMessage.messages[0] });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n})\r\n\r\nvar cooldowns = {\r\n    \"000000@g.us\": new Date().getTime(),\r\n    \"000000@s.whatsapp.net\": new Date().getTime()\r\n}\r\n\r\naddCommand({ pattern: \"onMessage\", dontAddCommandList: true, access: \"all\" }, async (msg, match, sock, rawMessage) => {\r\n    var fincCooldowns = cooldowns[msg.key.remoteJid];\r\n    if (!fincCooldowns) {\r\n        cooldowns[msg.key.remoteJid] = new Date().getTime();\r\n    } else {\r\n        var newDate = new Date().getTime();\r\n        var timeDiff = Math.abs(newDate - fincCooldowns);\r\n        if (timeDiff < 5000) {\r\n            return;\r\n        }\r\n    }\r\n    const generalChatConfigs = global.database?.o3miniConfigs || false;\r\n    const quotedMessage = msg?.quotedMessage?.conversation || msg?.quotedMessage?.extendedTextMessage?.text || \"\";\r\n    if (generalChatConfigs && (((msg?.message?.conversation || msg?.message?.extendedTextMessage?.text) && (quotedMessage !== \"\")) || (msg.text && msg.text.includes(\"@\" + sock.user.id.split(\":\")[0])))) {\r\n        var findO3SessioninDb = global.database.o3mini.find(session => session.groupId == msg.key.remoteJid);\r\n        if (findO3SessioninDb || (sock.user.id.split(\":\")[0] == msg.key.remoteJid.split(\"@\")[0] && msg.key.fromMe) ) {\r\n            if (generalChatConfigs.onlyGroup && !findO3SessioninDb.groupId.startsWith(\"g\")) return;\r\n            if (generalChatConfigs.onlyPrivate && findO3SessioninDb.groupId.startsWith(\"g\")) return;\r\n            if (generalChatConfigs.lockAllChats) return;\r\n            if (!findO3SessioninDb.active) return;\r\n            if (msg.key.fromMe && (sock.user.id.split(\":\")[0] !== msg.key.remoteJid.split(\"@\")[0])) return;\r\n            var getSystemPrompt = generalChatConfigs.generalSystemPrompt === \"\" ? findO3SessioninDb.systemPrompt : generalChatConfigs.generalSystemPrompt;\r\n            var payload = {\r\n                query: msg.text.replace(\"@\" + sock.user.id.split(\":\")[0], \"\")\r\n            }\r\n            var ownerId = \"@\" + sock.user.id.split(\":\")[0];\r\n            if (getSystemPrompt !== \"\") payload.systemPrompt = getSystemPrompt;\r\n            if (quotedMessage !== \"\") payload.replyContent = quotedMessage.replace(ownerId, \"\").trimStart();\r\n            if (payload?.replyContent == \"\") payload.replyContent = \"?\"\r\n            await sock.sendPresenceUpdate('composing', msg.key.remoteJid) \r\n            payload.implementation = process.env\r\n            var response = await axios({\r\n                url: \"https:\/\/create.thena.workers.dev\/chat\",\r\n                method: \"post\",\r\n                data: payload\r\n            })\r\n            var responseMessage = response.data;\r\n            await sock.sendPresenceUpdate('paused', msg.key.remoteJid)\r\n            cooldowns[msg.key.remoteJid] = new Date().getTime();\r\n            if (responseMessage.status !== 200) {\r\n                if (msg.key.fromMe && (sock.user.id.split(\":\")[0] == msg.key.remoteJid.split(\"@\")[0])) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Error: \" + responseMessage.content + \"_\" });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Error: \" + responseMessage.content + \"_\" }, { quoted: rawMessage.messages[0] });\r\n            } else {\r\n                global.database.o3mini[global.database.o3mini.findIndex(session => session.groupId == msg.key.remoteJid)].totalMessages++\r\n                if (msg.key.fromMe && (sock.user.id.split(\":\")[0] == msg.key.remoteJid.split(\"@\")[0])) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: responseMessage.content.replace(\/\\\\n\/gmi, '\\n') });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: responseMessage.content.replace(\/\\\\n\/gmi, '\\n').replace(\/(\\\\\"|\\\\')<\/gmi, '\"') }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n    }\r\n})",
        "videoPath": ".\/src\/gpt.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "QuotLy",
        "keywords": [
            "sticker",
            "quotely",
            "quotly",
            "image",
            "sticker geneerator"
        ],
        "usage": "menu q",
        "pluginId": "quotly",
        "description": "Generate stickers from text!",
        "downloads": 52,
        "pluginVersion": "1.1.4",
        "pluginFileName": "quotely.js",
        "context": "const axios = require('axios');\r\nconst ffmpeg = require('fluent-ffmpeg');\r\nconst ffmpegPath = require('@ffmpeg-installer\/ffmpeg').path;\r\nffmpeg.setFfmpegPath(ffmpegPath);\r\nconst fs = require('fs');\r\n\r\nvar colorMap = {\r\n    \"-t\": \"transparent\",\r\n    \"-transparent\": \"transparent\",\r\n    \"-trans\": \"transparent\",\r\n    \"-green\": \"#008000\",\r\n    \"-red\": \"#FF0000\",\r\n    \"-blue\": \"#0000FF\",\r\n    \"-yellow\": \"#FFFF00\",\r\n    \"-purple\": \"#800080\",\r\n    \"-orange\": \"#FFA500\",\r\n    \"-pink\": \"#FFC0CB\",\r\n    \"-cyan\": \"#00FFFF\",\r\n    \"-brown\": \"#A52A2A\",\r\n    \"-gray\": \"#808080\",\r\n    \"-black\": \"#000000\",\r\n    \"-white\": \"#FFFFFF\",\r\n    \"-lightgrey\": \"#D3D3D3\",\r\n    \"-lightgreen\": \"#90EE90\",\r\n    \"-lightred\": \"#FFB6C1\",\r\n    \"-lightblue\": \"#ADD8E6\",\r\n    \"-lightyellow\": \"#FFFFE0\",\r\n    \"-lightpurple\": \"#D8BFD8\",\r\n    \"-lightorange\": \"#FFDAB9\",\r\n    \"-lightpink\": \"#FFC0CB\",\r\n    \"-lightcyan\": \"#E0FFFF\",\r\n    \"-lightbrown\": \"#A0522D\",\r\n    \"-lightgray\": \"#D3D3D3\",\r\n    \"-darkgreen\": \"#006400\",\r\n    \"-darkred\": \"#8B0000\",\r\n    \"-darkblue\": \"#00008B\",\r\n    \"-darkyellow\": \"#B8860B\",\r\n    \"-darkpurple\": \"#800080\",\r\n    \"-darkorange\": \"#A52A2A\",\r\n    \"-darkpink\": \"#FF1493\",\r\n    \"-darkcyan\": \"#008B8B\",\r\n    \"-darkbrown\": \"#8B4513\",\r\n    \"-darkgray\": \"#A9A9A9\",\r\n    \"-violet\": \"#EE82EE\",\r\n    \"-indigo\": \"#4B0082\",\r\n    \"-magenta\": \"#FF00FF\",\r\n    \"-teal\": \"#008080\",\r\n    \"-lime\": \"#00FF00\",\r\n    \"-maroon\": \"#800000\",\r\n    \"-olive\": \"#808000\",\r\n    \"-navy\": \"#000080\",\r\n    \"-fuchsia\": \"#FF00FF\",\r\n    \"-aqua\": \"#00FFFF\",\r\n    \"-silver\": \"#C0C0C0\",\r\n    \"-gold\": \"#FFD700\",\r\n    \"-coral\": \"#FF7F50\",\r\n    \"-orchid\": \"#DA70D6\",\r\n    \"-lavender\": \"#E6E6FA\",\r\n    \"-plum\": \"#DDA0DD\",\r\n    \"-tan\": \"#D2B48C\",\r\n    \"-peach\": \"#FFE5B4\",\r\n    \"-khaki\": \"#F0E68C\",\r\n    \"-wheat\": \"#F5DEB3\",\r\n    \"-linen\": \"#FAF0E6\",\r\n    \"-beige\": \"#F5F5DC\",\r\n    \"-azure\": \"#F0FFFF\",\r\n    \"-honeydew\": \"#F0FFF0\",\r\n    \"-mint\": \"#F5FFFA\",\r\n    \"-snow\": \"#FFFAFA\",\r\n    \"-ivory\": \"#FFFFF0\",\r\n    \"-aliceblue\": \"#F0F8FF\",\r\n    \"-ghostwhite\": \"#F8F8FF\",\r\n    \"-whitesmoke\": \"#F5F5F5\",\r\n    \"-seashell\": \"#FFF5EE\",\r\n    \"-mintcream\": \"#F5FFFA\",\r\n    \"-blanchedalmond\": \"#FFEBCD\",\r\n    \"-bisque\": \"#FFE4C4\",\r\n    \"-navajowhite\": \"#FFDEAD\",\r\n    \"-cornsilk\": \"#FFF8DC\",\r\n    \"-lemonchiffon\": \"#FFFACD\",\r\n    \"-floralwhite\": \"#FFFAF0\",\r\n    \"-oldlace\": \"#FDF5E6\",\r\n    \"-antiquewhite\": \"#FAEBD7\",\r\n    \"-papayawhip\": \"#FFEFD5\",\r\n    \"-crimson\": \"#DC143C\",\r\n    \"-indianred\": \"#CD5C5C\",\r\n    \"-slateblue\": \"#6A5ACD\",\r\n    \"-mediumseagreen\": \"#3CB371\",\r\n    \"-mediumturquoise\": \"#48D1CC\",\r\n    \"-royalblue\": \"#4169E1\",\r\n    \"-darkslateblue\": \"#483D8B\",\r\n    \"-darkslategray\": \"#2F4F4F\",\r\n    \"-scarlet\": \"#FF2400\",\r\n    \"-chartreuse\": \"#7FFF00\",\r\n    \"-cerulean\": \"#007BA7\",\r\n    \"-periwinkle\": \"#CCCCFF\",\r\n    \"-aquamarine\": \"#7FFFD4\",\r\n    \"-blueviolet\": \"#8A2BE2\",\r\n    \"-burlywood\": \"#DEB887\",\r\n    \"-cadetblue\": \"#5F9EA0\",\r\n    \"-chocolate\": \"#D2691E\",\r\n    \"-cornflowerblue\": \"#6495ED\",\r\n    \"-darkgoldenrod\": \"#B8860B\",\r\n    \"-darkgrey\": \"#A9A9A9\",\r\n    \"-darkkhaki\": \"#BDB76B\",\r\n    \"-darkmagenta\": \"#8B008B\",\r\n    \"-darkolivegreen\": \"#556B2F\",\r\n    \"-darkorchid\": \"#9932CC\",\r\n    \"-darksalmon\": \"#E9967A\",\r\n    \"-darkseagreen\": \"#8FBC8F\",\r\n    \"-darkslategrey\": \"#2F4F4F\",\r\n    \"-darkturquoise\": \"#00CED1\",\r\n    \"-darkviolet\": \"#9400D3\",\r\n    \"-deeppink\": \"#FF1493\",\r\n    \"-deepskyblue\": \"#00BFFF\",\r\n    \"-dimgray\": \"#696969\",\r\n    \"-dimgrey\": \"#696969\",\r\n    \"-dodgerblue\": \"#1E90FF\",\r\n    \"-firebrick\": \"#B22222\",\r\n    \"-forestgreen\": \"#228B22\",\r\n    \"-gainsboro\": \"#DCDCDC\",\r\n    \"-goldenrod\": \"#DAA520\",\r\n    \"-greenyellow\": \"#ADFF2F\",\r\n    \"-grey\": \"#808080\",\r\n    \"-hotpink\": \"#FF69B4\",\r\n    \"-lavenderblush\": \"#FFF0F5\",\r\n    \"-lawngreen\": \"#7CFC00\",\r\n    \"-lightcoral\": \"#F08080\",\r\n    \"-lightgoldenrodyellow\": \"#FAFAD2\",\r\n    \"-lightsalmon\": \"#FFA07A\",\r\n    \"-lightseagreen\": \"#20B2AA\",\r\n    \"-lightskyblue\": \"#87CEFA\",\r\n    \"-lightslategray\": \"#778899\",\r\n    \"-lightslategrey\": \"#778899\",\r\n    \"-lightsteelblue\": \"#B0C4DE\",\r\n    \"-limegreen\": \"#32CD32\",\r\n    \"-mediumaquamarine\": \"#66CDAA\",\r\n    \"-mediumblue\": \"#0000CD\",\r\n    \"-mediumorchid\": \"#BA55D3\",\r\n    \"-mediumpurple\": \"#9370DB\",\r\n    \"-mediumslateblue\": \"#7B68EE\",\r\n    \"-mediumspringgreen\": \"#00FA9A\",\r\n    \"-mediumvioletred\": \"#C71585\",\r\n    \"-midnightblue\": \"#191970\",\r\n    \"-mistyrose\": \"#FFE4E1\",\r\n    \"-moccasin\": \"#FFE4B5\",\r\n    \"-olivedrab\": \"#6B8E23\",\r\n    \"-orangered\": \"#FF4500\",\r\n    \"-palegoldenrod\": \"#EEE8AA\",\r\n    \"-palegreen\": \"#98FB98\",\r\n    \"-paleturquoise\": \"#AFEEEE\",\r\n    \"-palevioletred\": \"#DB7093\",\r\n    \"-peachpuff\": \"#FFDAB9\",\r\n    \"-peru\": \"#CD853F\",\r\n    \"-powderblue\": \"#B0E0E6\",\r\n    \"-rebeccapurple\": \"#663399\",\r\n    \"-rosybrown\": \"#BC8F8F\",\r\n    \"-saddlebrown\": \"#8B4513\",\r\n    \"-salmon\": \"#FA8072\",\r\n    \"-sandybrown\": \"#F4A460\",\r\n    \"-seagreen\": \"#2E8B57\",\r\n    \"-sienna\": \"#A0522D\",\r\n    \"-skyblue\": \"#87CEEB\",\r\n    \"-slategray\": \"#708090\",\r\n    \"-slategrey\": \"#708090\",\r\n    \"-springgreen\": \"#00FF7F\",\r\n    \"-steelblue\": \"#4682B4\",\r\n    \"-thistle\": \"#D8BFD8\",\r\n    \"-tomato\": \"#FF6347\",\r\n    \"-turquoise\": \"#40E0D0\",\r\n    \"-yellowgreen\": \"#9ACD32\"\r\n}\r\n\r\naddCommand({ pattern: \"^q ?([\\\\s\\\\S]*)\", access: \"all\", desc: \"_Generate stickers from text._\", usage: global.handlers[0] + \"q <text or reply> <color(-red, -t, -cyan etc.)>\", pluginVersion: \"1.1.4\", pluginId: \"quotly\"}, async (msg, match, sock, rawMessage) => {\r\n    var text = match[1]\r\n\r\n    if (!text && !msg.quotedMessage) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please write a text or reply to a message!_\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please write a text or reply to a message!_\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: \"_‚è≥ Generating.._\", edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: \"_‚è≥ Generating.._\" }, { quoted: rawMessage.messages[0] });\r\n    }\r\n    var randomHexColor = \"#134d37\" || \"#\" + Math.floor(Math.random() * 16777215).toString(16);\r\n\r\n    var payloadData;\r\n    try {\r\n        if (msg.quotedMessage) {\r\n            const quoted = msg.quotedMessage;\r\n            var bgColor = randomHexColor;\r\n            if (text) {\r\n                var color = text.match(\/-[a-zA-Z]+\/gmi);\r\n                if (color) {\r\n                    if (colorMap[color[0]]) {\r\n                        bgColor = colorMap[color[0]];\r\n                        text = text.replace(color[0], \"\")\r\n                    }\r\n                }\r\n            }\r\n\r\n            var codeText = quoted.conversation ? quoted.conversation : quoted.extendedTextMessage.text\r\n\r\n            var codeTextArray = codeText.split(\" \");\r\n            var finalCodeText = \"\";\r\n            var i2 = 0\r\n            for (var i = 0; i < codeTextArray.length; i++) {\r\n                i2++\r\n                if (i2 == 4) {\r\n                  finalCodeText += codeTextArray[i]+ \" \" + \"\\n\"\r\n                  i2 = 0\r\n                } else {\r\n                  finalCodeText += codeTextArray[i] + \" \"\r\n                }\r\n            }\r\n            finalCodeText = finalCodeText.trimEnd().trimStart()\r\n\r\n            payloadData = {\r\n                type: \"quote\",\r\n                format: \"png\",\r\n                backgroundColor: bgColor,\r\n                width: 768,\r\n                height: 512,\r\n                scale: 2,\r\n                messages: [\r\n                    {\r\n                        entities: [],\r\n                        avatar: true,\r\n                        from: {\r\n                            id: 1,\r\n                            name: rawMessage.messages[0].message?.extendedTextMessage?.contextInfo?.participant ? global.database.users[rawMessage.messages[0].message?.extendedTextMessage?.contextInfo?.participant] :global.database.users[rawMessage.messages[0].key.participant ? rawMessage.messages[0].key.participant : rawMessage.messages[0].key.remoteJid],\r\n                            photo: {\r\n                                url: await sock.profilePictureUrl(rawMessage.messages[0].message?.extendedTextMessage?.contextInfo?.participant || global.database.users[rawMessage.messages[0].key.participant ? rawMessage.messages[0].key.participant : rawMessage.messages[0].key.remoteJid])\r\n                            }\r\n                        },\r\n                        text: finalCodeText,\r\n                        replyMessage: {}\r\n                    }\r\n                ]\r\n            };\r\n        } else {\r\n            var bgColor = randomHexColor;\r\n            if (text) {\r\n                var color = text.match(\/-[a-zA-Z]+\/gmi);\r\n                if (color) {\r\n                    if (colorMap[color[0]]) {\r\n                        bgColor = colorMap[color[0]];\r\n                        text = text.replace(color[0], \"\")\r\n                    }\r\n                }\r\n            }\r\n\r\n            var codeTextArray = text.split(\" \");\r\n            var finalCodeText = \"\";\r\n            var i2 = 0\r\n            for (var i = 0; i < codeTextArray.length; i++) {\r\n                i2++\r\n                if (i2 == 4) {\r\n                  finalCodeText += codeTextArray[i]+ \" \" + \"\\n\"\r\n                  i2 = 0\r\n                } else {\r\n                  finalCodeText += codeTextArray[i] + \" \"\r\n                }\r\n            }\r\n            finalCodeText = finalCodeText.trimEnd().trimStart()\r\n\r\n            payloadData = {\r\n                type: \"quote\",\r\n                format: \"png\",\r\n                backgroundColor: bgColor,\r\n                width: 768,\r\n                height: 512,\r\n                scale: 2,\r\n                messages: [\r\n                    {\r\n                        entities: [],\r\n                        avatar: true,\r\n                        from: {\r\n                            id: 1,\r\n                            name: msg.pushName,\r\n                            photo: {\r\n                                url: await sock.profilePictureUrl(msg.key.participant)\r\n                            }\r\n                        },   \r\n                        text: finalCodeText,\r\n                        replyMessage: {}\r\n                    }\r\n                ]\r\n            };\r\n        }\r\n    } catch {\r\n        const errorText = \"_‚ùå Failed to generate quote. Please reply a text message!_\";\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: errorText, edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: errorText, edit: publicMessage.key });\r\n        }\r\n        return;\r\n    }\r\n\r\n    try {\r\n        var generateQuote = await axios({\r\n            url: \"https:\/\/bot.lyo.su\/quote\/generate\",\r\n            method: \"POST\",\r\n            data: payloadData,\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\"\r\n            }\r\n        })\r\n        if (generateQuote.data.ok == true) {\r\n            const imagePath = \".\/src\/quote\" + Math.floor(Math.random() * 100) + \".png\";\r\n            const imagePath2 = \".\/src\/quote\" + Math.floor(Math.random() * 10000) + \".webp\";\r\n            fs.writeFileSync(imagePath, generateQuote.data.result.image, 'base64');\r\n            ffmpeg(imagePath).outputOptions([\"-y\", \"-vcodec libwebp\"]).videoFilters('scale=2000:2000:flags=lanczos:force_original_aspect_ratio=decrease,format=rgba,pad=2000:2000:(ow-iw)\/2:(oh-ih)\/2:color=#00000000,setsar=1').save(imagePath2).on('end', async () => {\r\n                if (msg.key.fromMe) {\r\n                    await sock.sendMessage(msg.key.remoteJid, { delete: msg.key });\r\n                    await sock.sendMessage(msg.key.remoteJid, { sticker: { url: imagePath2 } });\r\n                } else {\r\n                    await sock.sendMessage(msg.key.remoteJid, { delete: publicMessage.key });\r\n                    await sock.sendMessage(msg.key.remoteJid, { sticker: { url: imagePath2 } }, { quoted: rawMessage.messages[0] });\r\n                }\r\n                [imagePath, imagePath2].forEach(file => {\r\n                    if (fs.existsSync(file)) try { fs.unlinkSync(file) } catch { }\r\n                });\r\n                return\r\n            });\r\n        } else {\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Something went wrong!_\", edit: msg.key });\r\n            } else {\r\n                await sock.sendMessage(msg.key.remoteJid, { delete: publicMessage.key });\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Something went wrong!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n    } catch {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Something went wrong!_\", edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { delete: publicMessage.key });\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Something went wrong!_\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n})",
        "videoPath": ".\/src\/quot.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "How All",
        "keywords": [
            "howall",
            "test",
            "gay",
            "ass",
            "boob",
            "boobs",
            "how",
            "all",
            "femboy",
            "iq",
            "iq test",
            "gay test",
            "lesbian",
            "lesbian test"
        ],
        "usage": "menu howall",
        "pluginId": "howall",
        "description": "Test your IQ, Gay, Lesbian, and more!",
        "downloads": 3,
        "pluginVersion": "1.0.0",
        "pluginFileName": "howall.js",
        "context": "setInterval(async () => {\r\n    if (!global.database || !global.database.daily_lovers) return;\r\n    const currentTime = new Date().getTime();\r\n    for (const groupId in global.database.daily_lovers) {\r\n        const lastTime = global.database.daily_lovers[groupId];\r\n        if (currentTime - lastTime > 86400000) {\r\n            try {\r\n                const groupData = await global.sock.groupMetadata(groupId);\r\n                let participants = groupData.participants.filter(participant => participant.id !== global.sock.user.id.split(\":\")[0] + \"@s.whatsapp.net\");\r\n                if (participants.length < 2) continue;\r\n                const firstIndex = Math.floor(Math.random() * participants.length);\r\n                let secondIndex;\r\n                do {\r\n                    secondIndex = Math.floor(Math.random() * participants.length);\r\n                } while (secondIndex === firstIndex);\r\n                \r\n                try {\r\n                    await global.sock.sendMessage(groupId, { text: `üíñ *Daily Lovers* üíñ\\n\\n` + \"üíå @\" + participants[firstIndex].id.split(\"@\")[0] + \" üíû \" + \"@\" + participants[secondIndex].id.split(\"@\")[0], mentions: [participants[firstIndex].id, participants[secondIndex].id] });\r\n                } catch {}\r\n                global.database.daily_lovers[groupId] = new Date().getTime();\r\n            } catch {}\r\n        }\r\n    }\r\n}, 100000);\r\n\r\n\r\naddCommand({ pattern: \"^howall ?(.*)\", access: \"all\", desc: \"_Test your Allness. Totally accurate! (not)_\", pluginVersion: \"1.0.0\", pluginId: \"howall\" }, async (msg, match, sock, rawMessage) => {\r\n\r\n    if (!global.database.hasOwnProperty(\"daily_lovers\")) global.database.daily_lovers = {};\r\n    if (!global.database.daily_lovers.hasOwnProperty(msg.key.remoteJid)) global.database.daily_lovers[msg.key.remoteJid] = new Date().getTime();\r\n\r\n    const generateRandomValue = (probabilities, ranges) => {\r\n        const random = Math.random();\r\n        for (let i = 0; i < probabilities.length; i++) {\r\n            if (random < probabilities[i]) return Math.floor(Math.random() * (ranges[i][1] - ranges[i][0] + 1)) + ranges[i][0];\r\n        }\r\n        return Math.floor(Math.random() * (ranges[ranges.length - 1][1] - ranges[ranges.length - 1][0] + 1)) + ranges[ranges.length - 1][0];\r\n    };\r\n\r\n    const score = Math.floor(Math.random() * 101);\r\n    const iqScore = generateRandomValue([0.6, 0.8, 0.9, 0.97], [[50, 105], [105, 120], [120, 130], [130, 135], [135, 140]]);\r\n    const cockSize = generateRandomValue([0.1, 0.5, 0.8, 0.9, 0.94], [[3, 8], [8, 12], [12, 16], [16, 19], [19, 25], [25, 32]]);\r\n    const assSize = generateRandomValue([0.305, 0.58, 0.748, 0.87, 0.938, 0.977, 0.992], [[50, 64], [64, 69], [69, 74], [74, 78], [78, 83], [83, 89], [89, 94], [94, 100]]);\r\n    const boobSize = generateRandomValue([0.343, 0.611, 0.801, 0.931, 0.984], [[60, 67], [67, 72], [72, 78], [78, 82], [82, 87], [87, 93]]);\r\n\r\n    const model = match[1]?.toLowerCase() || \"\";\r\n\r\n    const modelMessages = {\r\n        hug: async () => {\r\n            const participants = (await sock.groupMetadata(msg.key.remoteJid)).participants.filter(p => p.id.split(\"@\")[0] !== sock.user.id.split(\":\")[0]);\r\n            const text = participants.length === 0\r\n                ? `*ü§ó ${msg.pushName} hugged everyone!*`\r\n                : `*ü§ó ${msg.pushName} hugged @${participants[Math.floor(Math.random() * participants.length)].id.split(\"@\")[0]}!*`;\r\n            await sock.sendMessage(msg.key.remoteJid, { text: text, mentions: participants.map(p => p.id), edit: msg.key });\r\n            return \"\"\r\n        },\r\n        gay: () => `*üè≥Ô∏è‚Äçüåà ${msg.pushName} is ${score}% gay!*`,\r\n        iq: () => `*üß† ${msg.pushName} has ${iqScore} IQ!*`,\r\n        cock: () => `*üçÜ ${msg.pushName} has ${cockSize}cm cock!*`,\r\n        horny: () => `*üî• ${msg.pushName} is ${score}% horny!*`,\r\n        ass: () => `*üçë ${msg.pushName} has ${assSize}cm ass!*`,\r\n        boob: () => `*üëô ${msg.pushName} has ${boobSize}cm boobs!*`,\r\n        cute: () => `*ü•∞ ${msg.pushName} is ${score}% cute!*`,\r\n        femboy: () => `*üè≥Ô∏è‚Äç‚ößÔ∏è ${msg.pushName} is ${score}% femboy!*`,\r\n    };\r\n\r\n    if (modelMessages[model]) {\r\n        const text = await modelMessages[model]();\r\n        if (msg.key.fromMe) {\r\n            if (text !== \"\") {\r\n                await sock.sendMessage(msg.key.remoteJid, { text, edit: msg.key });\r\n                return;\r\n            }\r\n        } else {\r\n            if (text !== \"\") {\r\n                await sock.sendMessage(msg.key.remoteJid, { text} , { quoted: rawMessage.messages[0] });\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (text === \"\") return;\r\n    const defaultText = \"_Please select model!_\\n\\n_Available Models :: gay|iq|cock|horny|ass|boob|cute|hug|femboy_\";\r\n    if (msg.key.fromMe) {\r\n        return sock.sendMessage(msg.key.remoteJid, { text: defaultText, edit: msg.key });\r\n    } else {\r\n        return sock.sendMessage(msg.key.remoteJid, { text: defaultText }, { quoted: rawMessage.messages[0] });\r\n    }\r\n})",
        "videoPath": ".\/src\/howall.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "Minterpolate",
        "keywords": [
            "fps",
            "smooth",
            "interpolate",
            "interp",
            "video",
            "interpolate video",
            "smooth video",
            "fps increase",
            "media",
            "tool"
        ],
        "usage": "menu interp",
        "pluginId": "minterpolate",
        "description": "Interpolate videos. Make vidoes more smooth as 60FPS!",
        "downloads": 33,
        "pluginVersion": "1.0.4",
        "pluginFileName": "minterpolate.js",
        "context": "const ffmpeg = require('fluent-ffmpeg');\r\nconst ffmpegPath = require('@ffmpeg-installer\/ffmpeg').path;\r\nffmpeg.setFfmpegPath(ffmpegPath);\r\nconst fs = require('fs');\r\n\r\naddCommand({ pattern: \"^interp ?(.*)\", access: \"all\", desc: \"_Interpolate a video. Make vidoes more smooth._\", usage: global.handlers[0] + \"interp <fast || normal || quality>\", warn: \"_This command uses a lot of CPU power!_\", pluginVersion: \"1.0.4\", pluginId: \"minterpolate\" }, async (msg, match, sock, rawMessage) => {\r\n\r\n    if (!global.database?.interpOptions) {\r\n        global.database.interpOptions = {\r\n            maxLength: 15,\r\n            maxWidth: 800,\r\n            maxHeight: 800,\r\n            unlocked: false,\r\n        };\r\n}\r\n\r\n    if (!msg.quotedMessage || !msg.quotedMessage?.videoMessage) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please reply an video!_\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please reply an video!_\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    var videoLength = msg.quotedMessage.videoMessage.seconds;\r\n    var { width, height } = msg.quotedMessage.videoMessage;\r\n\r\n    if (global.database.interpOptions.unlocked == false) {\r\n        if (videoLength > global.database.interpOptions.maxLength) {\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video length is too long! Max length is \" + global.database.interpOptions.maxLength + \" seconds!_\\n\\n_To unlock interpolation limits, use \" + global.handlers[0] + \"interpunlock_\", edit: msg.key });\r\n            } else {\r\n                if (global.database.sudo.includes(msg.key.remoteJid)) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.interpOptions.maxWidth + \" pixels!_\\n\\n_To unlock interpolation limits, use \" + global.handlers[0] + \"interpunlock_\"}, { quoted: rawMessage.messages[0] });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video length is too long! Max length is \" + global.database.interpOptions.maxLength + \" seconds!_\\n\\n_To unlock interpolation limits, please contact the bot owner!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n        if (width > global.database.interpOptions.maxWidth) {\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.interpOptions.maxWidth + \" pixels!_\\n\\n_To unlock interpolation limits, use \" + global.handlers[0] + \"interpunlock_\", edit: msg.key });\r\n            } else {\r\n                if (global.database.sudo.includes(msg.key.remoteJid)) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.interpOptions.maxWidth + \" pixels!_\\n\\n_To unlock interpolation limits, use \" + global.handlers[0] + \"interpunlock_\"}, { quoted: rawMessage.messages[0] });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.interpOptions.maxWidth + \" pixels!_\\n\\n_To unlock interpolation limits, please contact the bot owner!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n        if (height > global.database.interpOptions.maxHeight) {\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video height is too big! Max height is \" + global.database.interpOptions.maxHeight + \" pixels!_\\n\\n_To unlock interpolation limits, use \" + global.handlers[0] + \"interpunlock_\", edit: msg.key });\r\n            } else {\r\n                if (global.database.sudo.includes(msg.key.remoteJid)) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.interpOptions.maxWidth + \" pixels!_\\n\\n_To unlock interpolation limits, use \" + global.handlers[0] + \"interpunlock_\"}, { quoted: rawMessage.messages[0] });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video height is too big! Max height is \" + global.database.interpOptions.maxHeight + \" pixels!_\\n\\n_To unlock interpolation limits, please contact the bot owner!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n    }\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: \"_‚è≥ Interpolating to 60FPS.._\", edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: \"_‚è≥ Interpolating to 60FPS.._\" }, { quoted: rawMessage.messages[0] });\r\n    }\r\n\r\n    var interpPath = \".\/src\/interp\" + Math.floor(Math.random() * 10000) + \".mp4\"\r\n    var interpPath2 = \".\/src\/interp2\" + Math.floor(Math.random() * 10000) + \".mp4\"\r\n    await global.downloadMedia(msg.quotedMessage.videoMessage, \"video\", interpPath);\r\n\r\n    var msgInterv = 0\r\n    var isDone = false\r\n    var mode = match[1] || \"normal\";\r\n    mode = mode.toLowerCase() == \"normal\" ? \"normal\" : mode.toLowerCase() == \"fast\" ? \"fast\" : \"quality\"\r\n\r\n    ffmpeg(interpPath)\r\n    .videoFilter(\r\n        mode == \"normal\" ? 'minterpolate=fps=60:mi_mode=mci:me_mode=bidir:me=tdls' :\r\n        mode == \"fast\" ? \"minterpolate=fps=60:mi_mode=mci:mc_mode=obmc:me_mode=bilat:me=epzs:search_param=8:vsbmc=0:scd=none\" :\r\n        \"minterpolate=fps=60:mi_mode=mci:mc_mode=aobmc:me_mode=bidir:me=tss:vsbmc=1:scd=fdiff:search_param=32\"\r\n    )\r\n    .videoCodec('libx264')\r\n    .outputOptions(\r\n        [\r\n            '-preset', 'ultrafast',\r\n            '-crf', mode == \"normal\" || mode == \"fast\" ? '22' : '17',\r\n        ]\r\n    )\r\n    .audioCodec('copy')\r\n    .format('mp4')\r\n    .save(interpPath2)\r\n    .on(\"progress\", async (progress) => {\r\n        if (msgInterv >= 2) {\r\n            msgInterv = 0\r\n            var timemarkParts = progress.timemark.split(':');\r\n            var seconds = (+timemarkParts[0]) * 60 * 60 + (+timemarkParts[1]) * 60 + (+timemarkParts[2].split('.')[0]) + (+timemarkParts[2].split('.')[1] \/ 100);\r\n            var progress_percent = ((seconds \/ videoLength) * 100).toFixed(2);        \r\n            progress_percent = progress_percent >= 100 ? 100 : progress_percent;\r\n            var modeName = mode == \"normal\" ? \"Normal\" : mode == \"fast\" ? \"Fast\" : \"Quality\"\r\n\r\n            if (progress_percent < 100) {\r\n                if (msg.key.fromMe) {\r\n                    await sock.sendMessage(msg.key.remoteJid, { text: `_Interpolating to 60FPS (${modeName} Mode)..._\\n\\n_Progress: ${progress_percent}%_\\n_Speed: ${progress.currentFps} FPS\/s_`, edit: msg.key });\r\n                } else {\r\n                    await sock.sendMessage(msg.key.remoteJid, { text: `_Interpolating to 60FPS (${modeName} Mode)..._\\n\\n_Progress: ${progress_percent}%_\\n_Speed: ${progress.currentFps} FPS\/s_`, edit: publicMessage.key });\r\n                }\r\n            } else {\r\n                if (isDone == false) {\r\n                    isDone = true\r\n                    if (msg.key.fromMe) {\r\n                        await sock.sendMessage(msg.key.remoteJid, { text: `_Interpolating to 60FPS (${modeName} Mode)..._\\n\\n_Decoding..._`, edit: msg.key });\r\n                    } else {\r\n                        await sock.sendMessage(msg.key.remoteJid, { text: `_Interpolating to 60FPS (${modeName} Mode)..._\\n\\n_Decoding..._`, edit: publicMessage.key });\r\n                    }\r\n                }\r\n            }\r\n            \r\n        } else {\r\n            msgInterv++\r\n        }\r\n    })\r\n    .on(\"end\", async () => {\r\n        var modeName = mode == \"normal\" ? \"Normal\" : mode == \"fast\" ? \"Fast\" : \"Quality\"\r\n\r\n        if (msg.key.fromMe) {\r\n            try { await sock.sendMessage(msg.key.remoteJid, { delete: msg.key }); } catch {}\r\n            await sock.sendMessage(msg.key.remoteJid, { video: { url: interpPath2 }, caption: \"_Interpolated video to 60FPS! (\" + modeName + \" Mode)_\" });\r\n        } else {\r\n            try { await sock.sendMessage(msg.key.remoteJid, { delete: publicMessage.key }); } catch {}\r\n            await sock.sendMessage(msg.key.remoteJid, { video: { url: interpPath2 }, caption: \"_Interpolated video to 60FPS! (\" + modeName + \" Mode)_\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n\r\n        [interpPath, interpPath2].forEach(file => {\r\n            try { if (fs.existsSync(file)) fs.unlinkSync(file) } catch { }\r\n        });\r\n    })\r\n})\r\n\r\naddCommand({ pattern: \"^interpunlock$\", access: \"sudo\", dontAddCommandList: true }, async (msg, match, sock, rawMessage) => {\r\n    if (!global.database?.interpOptions) {\r\n        global.database.interpOptions = {\r\n            maxLength: 20,\r\n            maxWidth: 800,\r\n            maxHeight: 800,\r\n            unlocked: false,\r\n        };\r\n    }\r\n\r\n    if (global.database?.interpOptions.unlocked == true) {\r\n        global.database.interpOptions.unlocked = false;\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Interpolation limits locked!_\", edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Interpolation limits locked!_\", edit: rawMessage.messages[0] });\r\n        }\r\n        return;\r\n    } else {\r\n        global.database.interpOptions.unlocked = true;\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Interpolation limits unlocked!_\", edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Interpolation limits unlocked!_\", edit: rawMessage.messages[0] });\r\n        }\r\n    }\r\n})\r\n\r\n",
        "videoPath": ".\/src\/interp.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "Super SlowMo",
        "keywords": [
            "fps",
            "smooth",
            "interpolate",
            "slowmo",
            "slow",
            "240fps",
            "super slowmo",
            "slow motion",
            "video",
            "smooth video",
            "fps increase",
            "media",
            "tool"
        ],
        "usage": "menu slowmo",
        "pluginId": "slowmo",
        "description": "Make videos 240FPS slow motion.",
        "downloads": 5,
        "pluginVersion": "1.0.0",
        "pluginFileName": "super_slowmo.js",
        "context": "const ffmpeg = require('fluent-ffmpeg');\r\nconst ffmpegPath = require('@ffmpeg-installer\/ffmpeg').path;\r\nffmpeg.setFfmpegPath(ffmpegPath);\r\nconst fs = require('fs');\r\n\r\naddCommand({ pattern: \"^slowmo ?(.*)\", access: \"all\", desc: \"_Make videos 240FPS slow motion._\", usage: global.handlers[0] + \"slowmo <fast || normal || quality>\", warn: \"_This command uses a lot of CPU power!_\", pluginVersion: \"1.0.0\", pluginId: \"slowmo\" }, async (msg, match, sock, rawMessage) => {\r\n\r\n    if (!global.database?.slowMoOptions) {\r\n        global.database.slowMoOptions = {\r\n            maxLength: 15,\r\n            maxWidth: 800,\r\n            maxHeight: 800,\r\n            unlocked: false,\r\n        };\r\n}\r\n\r\n    if (!msg.quotedMessage || !msg.quotedMessage?.videoMessage) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please reply an video!_\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please reply an video!_\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    var videoLength = msg.quotedMessage.videoMessage.seconds;\r\n    var { width, height } = msg.quotedMessage.videoMessage;\r\n\r\n    if (global.database.slowMoOptions.unlocked == false) {\r\n        if (videoLength > global.database.slowMoOptions.maxLength) {\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video length is too long! Max length is \" + global.database.slowMoOptions.maxLength + \" seconds!_\\n\\n_To unlock slow motion limits, use \" + global.handlers[0] + \"slowmounlock_\", edit: msg.key });\r\n            } else {\r\n                if (global.sudo.includes(msg.key.remoteJid)) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.slowMoOptions.maxWidth + \" pixels!_\\n\\n_To unlock slow motion limits, use \" + global.handlers[0] + \"slowmounlock_\"}, { quoted: rawMessage.messages[0] });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video length is too long! Max length is \" + global.database.slowMoOptions.maxLength + \" seconds!_\\n\\n_To unlock slow motion limits, please contact the bot owner!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n        if (width > global.database.slowMoOptions.maxWidth) {\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.slowMoOptions.maxWidth + \" pixels!_\\n\\n_To unlock slow motion limits, use \" + global.handlers[0] + \"slowmounlock_\", edit: msg.key });\r\n            } else {\r\n                if (global.sudo.includes(msg.key.remoteJid)) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.slowMoOptions.maxWidth + \" pixels!_\\n\\n_To unlock slow motion limits, use \" + global.handlers[0] + \"slowmounlock_\"}, { quoted: rawMessage.messages[0] });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.slowMoOptions.maxWidth + \" pixels!_\\n\\n_To unlock slow motion limits, please contact the bot owner!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n        if (height > global.database.slowMoOptions.maxHeight) {\r\n            if (msg.key.fromMe) {\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video height is too big! Max height is \" + global.database.slowMoOptions.maxHeight + \" pixels!_\\n\\n_To unlock slow motion limits, use \" + global.handlers[0] + \"slowmounlock_\", edit: msg.key });\r\n            } else {\r\n                if (global.sudo.includes(msg.key.remoteJid)) {\r\n                    return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video width is too big! Max width is \" + global.database.slowMoOptions.maxWidth + \" pixels!_\\n\\n_To unlock slow motion limits, use \" + global.handlers[0] + \"slowmounlock_\"}, { quoted: rawMessage.messages[0] });\r\n                }\r\n                return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Video height is too big! Max height is \" + global.database.slowMoOptions.maxHeight + \" pixels!_\\n\\n_To unlock slow motion limits, please contact the bot owner!_\" }, { quoted: rawMessage.messages[0] });\r\n            }\r\n        }\r\n    }\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: \"_‚è≥ Applying slow motion.._\", edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: \"_‚è≥ Applying slow motion.._\" }, { quoted: rawMessage.messages[0] });\r\n    }\r\n\r\n    var slowPatch = \".\/src\/slow\" + Math.floor(Math.random() * 10000) + \".mp4\"\r\n    var slowPatch2 = \".\/src\/slow2\" + Math.floor(Math.random() * 10000) + \".mp4\"\r\n    await global.downloadMedia(msg.quotedMessage.videoMessage, \"video\", slowPatch);\r\n\r\n    var msgInterv = 0\r\n    var isDone = false\r\n    var mode = match[1] || \"normal\";\r\n    mode = mode.toLowerCase() == \"normal\" ? \"normal\" : mode.toLowerCase() == \"fast\" ? \"fast\" : \"quality\"\r\n\r\n    ffmpeg(slowPatch)\r\n    .videoFilter(\r\n        mode == \"normal\" ? 'minterpolate=fps=240:mi_mode=mci:me_mode=bidir:me=tdls' :\r\n        mode == \"fast\" ? \"minterpolate=fps=240:mi_mode=mci:mc_mode=obmc:me_mode=bilat:me=epzs:search_param=8:vsbmc=0:scd=none\" :\r\n        \"minterpolate=fps=240:mi_mode=mci:mc_mode=aobmc:me_mode=bidir:me=tss:vsbmc=1:scd=fdiff:search_param=32\"\r\n    )\r\n    .videoFilter(\"setpts=2.5*PTS\")\r\n    .videoCodec('libx264')\r\n    .outputOptions(\r\n        [\r\n            '-preset', 'ultrafast',\r\n            '-crf', mode == \"normal\" || mode == \"fast\" ? '22' : '17',\r\n        ]\r\n    )\r\n    .noAudio()\r\n    .format('mp4')\r\n    .save(slowPatch2)\r\n    .on(\"progress\", async (progress) => {\r\n        if (msgInterv >= 2) {\r\n            msgInterv = 0\r\n            var timemarkParts = progress.timemark.split(':');\r\n            var seconds = (+timemarkParts[0]) * 60 * 60 + (+timemarkParts[1]) * 60 + (+timemarkParts[2].split('.')[0]) + (+timemarkParts[2].split('.')[1] \/ 100);\r\n            var progress_percent = ((seconds \/ videoLength) * 100).toFixed(2);        \r\n            progress_percent = progress_percent >= 100 ? 100 : progress_percent;\r\n            var modeName = mode == \"normal\" ? \"Normal\" : mode == \"fast\" ? \"Fast\" : \"Quality\"\r\n\r\n            if (progress_percent < 100) {\r\n                if (msg.key.fromMe) {\r\n                    await sock.sendMessage(msg.key.remoteJid, { text: `_Applying slow motion (${modeName} Mode)..._\\n\\n_Progress: ${progress_percent}%_\\n_Speed: ${progress.currentFps} FPS\/s_`, edit: msg.key });\r\n                } else {\r\n                    await sock.sendMessage(msg.key.remoteJid, { text: `_Applying slow motion (${modeName} Mode)..._\\n\\n_Progress: ${progress_percent}%_\\n_Speed: ${progress.currentFps} FPS\/s_`, edit: publicMessage.key });\r\n                }\r\n            } else {\r\n                if (isDone == false) {\r\n                    isDone = true\r\n                    if (msg.key.fromMe) {\r\n                        await sock.sendMessage(msg.key.remoteJid, { text: `_Applying slow motion (${modeName} Mode)..._\\n\\n_Decoding..._`, edit: msg.key });\r\n                    } else {\r\n                        await sock.sendMessage(msg.key.remoteJid, { text: `_Applying slow motion (${modeName} Mode)..._\\n\\n_Decoding..._`, edit: publicMessage.key });\r\n                    }\r\n                }\r\n            }\r\n            \r\n        } else {\r\n            msgInterv++\r\n        }\r\n    })\r\n    .on(\"end\", async () => {\r\n        var modeName = mode == \"normal\" ? \"Normal\" : mode == \"fast\" ? \"Fast\" : \"Quality\"\r\n\r\n        if (msg.key.fromMe) {\r\n            try { await sock.sendMessage(msg.key.remoteJid, { delete: msg.key }); } catch {}\r\n            await sock.sendMessage(msg.key.remoteJid, { video: { url: slowPatch2 }, caption: \"_Slow motion applied! (\" + modeName + \" Mode)_\" });\r\n        } else {\r\n            try { await sock.sendMessage(msg.key.remoteJid, { delete: publicMessage.key }); } catch {}\r\n            await sock.sendMessage(msg.key.remoteJid, { video: { url: slowPatch2 }, caption: \"_Slow motion applied! (\" + modeName + \" Mode)_\" }, { quoted: rawMessage.messages[0] });\r\n        }\r\n\r\n        [slowPatch, slowPatch2].forEach(file => {\r\n            try { if (fs.existsSync(file)) fs.unlinkSync(file) } catch { }\r\n        });\r\n    })\r\n})\r\n\r\naddCommand({ pattern: \"^slowmounlock$\", access: \"sudo\", dontAddCommandList: true }, async (msg, match, sock, rawMessage) => {\r\n    if (!global.database?.slowMoOptions) {\r\n        global.database.slowMoOptions = {\r\n            maxLength: 20,\r\n            maxWidth: 800,\r\n            maxHeight: 800,\r\n            unlocked: false,\r\n        };\r\n    }\r\n\r\n    if (global.database?.slowMoOptions.unlocked == true) {\r\n        global.database.slowMoOptions.unlocked = false;\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Slow motion limits locked!_\", edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Slow motion limits locked!_\", edit: rawMessage.messages[0] });\r\n        }\r\n        return;\r\n    } else {\r\n        global.database.slowMoOptions.unlocked = true;\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Slow motion limits unlocked!_\", edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: \"_‚úÖ Slow motion limits unlocked!_\", edit: rawMessage.messages[0] });\r\n        }\r\n    }\r\n})\r\n\r\n",
        "videoPath": ".\/src\/slowmo.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "Game Benchmarker",
        "keywords": [
            "fps",
            "game",
            "benchmark",
            "benchmarking",
            "can i run it",
            "excepted fps",
            "benchmark game",
            "system",
            "system benchmark",
            "system requirements",
            "game requirements",
            "gpu",
            "cpu",
            "ram"
        ],
        "usage": "menu gamefps",
        "pluginId": "gamefps",
        "description": "Get the average FPS of a game on your system.",
        "downloads": 4,
        "pluginVersion": "1.0.0",
        "pluginFileName": "game_sys_req.js",
        "context": "const axios = require('axios');\r\nconst cheerio = require('cheerio');\r\nvar FormData = require('form-data');\r\n\r\n\/**\r\n * Search for a game on game system requirements and return the first game found\r\n * @param {string} gameName - name of the game to search for\r\n * @returns {Promise<string>} - first game found, or empty string if not found\r\n *\/\r\nasync function searchGame(gameName) {\r\n     const apiUrl = \"https:\/\/gamesystemrequirements.com\/search?q=\" + encodeURIComponent(gameName) + \"&w=1&method=AND\"\r\n     var response = await axios.get(apiUrl);\r\n     response = response.data;\r\n     var $ = cheerio.load(response);\r\n     var tables = [];\r\n     var games = [];\r\n     $('tr').each((index, row) => {\r\n          tables.push($(row).html());\r\n     });\r\n     tables.forEach(table => {\r\n          if (table.includes(\"\/game\/\")) {\r\n               games.push(table.split('href=\"')[1].split('\"')[0]);\r\n          }\r\n     });\r\n     return games[0];\r\n}\r\n\r\n\/**\r\n * Search for a CPU on game system requirements and return the first CPU found\r\n * @param {string} cpuName - name of the CPU to search for\r\n * @returns {Promise<object>} - first CPU found, or an object with {cpu: \"not found\", id: 0} if not found\r\n *\/\r\nasync function searchCPU(cpuName) {\r\n     var data = await axios.get(\"https:\/\/gamesystemrequirements.com\/cpu_search.php?q=\" + encodeURIComponent(cpuName), {headers: {\"x-requested-with\": \"XMLHttpRequest\"}})\r\n     data = data.data;\r\n     if (Number(data.total_count) == 0) return {cpu: \"not found\", id: 0}\r\n     return {cpu: data.items[0].full_name, id: Number(data.items[0].id)}\r\n}\r\n\r\n\r\n\/**\r\n * Search for a GPU on game system requirements and return the first GPU found\r\n * @param {string} gpuName - name of the GPU to search for\r\n * @returns {Promise<object>} - first GPU found, or an object with {gpu: \"not found\", id: 0} if not found\r\n *\/\r\nasync function searchGPU(gpuName) {\r\n     var data = await axios.get(\"https:\/\/gamesystemrequirements.com\/gpu_search.php?q=\" + encodeURIComponent(gpuName), {headers: {\"x-requested-with\": \"XMLHttpRequest\"}});\r\n     data = data.data;\r\n     if (Number(data.total_count) == 0) return {gpu: \"not found\", id: 0}\r\n     return {gpu: data.items[0].full_name, id: Number(data.items[0].id)}\r\n}\r\n\r\n\/**\r\n * Retrieves the average FPS for a given game URL, CPU, and GPU.\r\n * The function returns a string containing the average FPS for each resolution.\r\n * The string is formatted as follows: \"Resolution: Quality :: FPS\\n\".\r\n * The resolutions are ordered from lowest to highest.\r\n * @param {string} url - URL of the game to retrieve the average FPS for.\r\n * @param {object} cpu - CPU to use for the average FPS calculation.\r\n * @param {object} gpu - GPU to use for the average FPS calculation.\r\n * @returns {Promise<string>} - A string containing the average FPS for each resolution.\r\n *\/\r\nasync function getAvarageFPS(url, cpu, gpu, ram) {\r\n\r\n     var formData = new FormData();\r\n     formData.append('device_id', \"0\");\r\n     formData.append('compare', \"Compare\");\r\n     formData.append('cpu', cpu.id);\r\n     formData.append('gpu', gpu.id);\r\n     formData.append('os', \"641110\");\r\n     formData.append('cpuoc', \"0\");\r\n     formData.append('vram', \"0\");\r\n     formData.append('gpuoc', \"0\");\r\n     formData.append('vcn', \"1\");\r\n     formData.append('ram', String(ram));\r\n\r\n     var data = await axios({\r\n          url: url,\r\n          method: \"POST\",\r\n          data: formData,\r\n          headers: formData.getHeaders()\r\n     })\r\n     data = data.data;\r\n\r\n     const $ = cheerio.load(data);\r\n     const results = [];\r\n     $('.main-panel').each((index, panel) => {\r\n         $(panel).find('.panel-title').each((i, title) => {\r\n             const titleText = $(title).text().trim();\r\n             if (titleText.includes(\"Expected fps:\")) {\r\n                    const srbrTabContent = $(panel).find('.srbr_tab').html();\r\n                    results.push({\r\n                         expectedFps: titleText,\r\n                         srbrTab: srbrTabContent ? srbrTabContent.trim() : \"Not Found\"\r\n                    });\r\n               }\r\n          });\r\n     });\r\n\r\n     const $2 = cheerio.load(results[0].srbrTab);\r\n     const jsonResult = {\r\n         resolutions: [],\r\n         fps_data: []\r\n     };\r\n     \r\n     $2('.srbr_row').first().find('.srbr_hc.center_text').each((i, el) => {\r\n         jsonResult.resolutions.push($(el).text().replace(\/\\n\/g, ' ').trim());\r\n     });\r\n     \r\n     $2('.srbr_row').slice(1).each((i, row) => {\r\n         const quality = $(row).find('.srbr_hc').first().text().trim();\r\n         const fps = $(row).find('.srbr_cell.center_text').map((j, cell) => $(cell).text().trim()).get();\r\n         \r\n         jsonResult.fps_data.push({ quality, fps });\r\n     });\r\n\r\n     \/**\r\n      * Converts the given data to a string containing the average FPS for each resolution.\r\n      * The string is formatted as follows: \"Resolution: Quality :: FPS\\n\".\r\n      * The resolutions are ordered from lowest to highest.\r\n      * @param {object} data - The data to convert to a string.\r\n      * @returns {string} - A string containing the average FPS for each resolution.\r\n      *\/\r\n     function convertToText(data) {\r\n          let textOutput = \"\";\r\n          data.resolutions.forEach((resolution, index) => {\r\n              textOutput += `\\n[${resolution.toUpperCase()}]\\n`;\r\n              data.fps_data.forEach(row => {\r\n                  textOutput += `${row.quality} :: ${row.fps[index]}\\n`;\r\n              });\r\n          });\r\n          return textOutput;\r\n     }\r\n     const textOutput = convertToText(jsonResult);\r\n     return textOutput;\r\n}\r\n\r\n\/\/ number to gb converter\r\n\/**\r\n * Converts the given GB value to the nearest available GB value.\r\n * If the input is not a number, it returns 16384 (16 GB).\r\n * If the input is less than 2 GB, it returns 2 GB.\r\n * If the input is greater than 64 GB, it returns 64 GB.\r\n * The available GB values are: 2, 4, 6, 8, 12, 16, 24, 32, 64.\r\n * If the input is not one of these values, it returns the closest available value.\r\n * @param {number} gb - The GB value to convert.\r\n * @returns {number} - The converted GB value in bytes.\r\n *\/\r\nfunction gbToNumber(gb) {\r\n     if (typeof gb !== \"number\") return 16 * 1024;\r\n     if (gb < 2) gb = 2\r\n     if (gb > 64) gb = 64\r\n     var availableGb = [2, 4, 6, 8, 12, 16, 24, 32, 64]\r\n     if (!availableGb.includes(gb)) {\r\n          var closest = availableGb.reduce((prev, curr) => {\r\n               return (Math.abs(curr - gb) < Math.abs(prev - gb) ? curr : prev);\r\n          });\r\n          gb = closest;\r\n     }\r\n     return gb * 1024;\r\n}\r\n\r\naddCommand({ pattern: \"^gamefps ?(.*)$\", access: \"all\", desc: \"_Get the average FPS of a game on your system._\", pluginVersion: \"1.0.0\", pluginId: \"gamefps\" }, async (msg, match, sock, rawMessage) => {\r\n\r\n     var example =  \"\\n\\n_Example:_ ```\" + global.handlers[0] + \"gamefps cyberpunk - 12500 - 4060 ti - 16```\";\r\n     if (!match[1]) {\r\n          if (msg.key.fromMe) {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_Please enter a game name, CPU, GPU, and RAM separated by -._\" + example, edit: msg.key });\r\n          } else {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_Please enter a game name, CPU, GPU, and RAM separated by -._\" + example }, { quoted: rawMessage.messages[0] });\r\n          }\r\n     }\r\n\r\n     var configs = match[1].split(\"-\")\r\n     if (configs.length != 4) {\r\n          if (msg.key.fromMe) {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_Please enter a game name, CPU, GPU, and RAM separated by -._\" + example, edit: msg.key });\r\n          } else {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_Please enter a game name, CPU, GPU, and RAM separated by -._\" + example }, { quoted: rawMessage.messages[0] });\r\n          }\r\n     }\r\n     configs.forEach((config, index) => {\r\n          configs[index] = config.trim();\r\n     });\r\n\r\n     if (msg.key.fromMe) {\r\n          await sock.sendMessage(msg.key.remoteJid, { text: \"_Searching for game..._\", edit: msg.key });\r\n     } else {\r\n          var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: \"_Searching for game..._\" }, { quoted: rawMessage.messages[0] });\r\n     }\r\n     var game = configs[0];\r\n     var cpu = configs[1];\r\n     var gpu1 = configs[2];\r\n     var ram = gbToNumber(Number(configs[3]));\r\n\r\n     var game2 = await searchGame(game);\r\n     if (!game2 || game2[0] == undefined) {\r\n          if (msg.key.fromMe) {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_Game not found._\" + example, edit: msg.key });\r\n          } else {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_Game not found._\" + example, edit: publicMessage.key });\r\n          }\r\n     }\r\n     var cpu2 = await searchCPU(cpu);\r\n     if (cpu2.id == 0) {\r\n          if (msg.key.fromMe) {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_CPU not found._\" + example, edit: msg.key });\r\n          } else {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_CPU not found._\" + example, edit: publicMessage.key });\r\n          }\r\n     }\r\n     var gpu22 = await searchGPU(gpu1);\r\n     if (gpu22.id == 0) {\r\n          if (msg.key.fromMe) {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_GPU not found._\" + example, edit: msg.key });\r\n          } else {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_GPU not found._\" + example, edit: publicMessage.key });\r\n          }\r\n     }\r\n     try {\r\n          var fps = await getAvarageFPS(game2, cpu2, gpu22, ram);\r\n     } catch {\r\n          var fps = \"Not Available\";\r\n     }\r\n\r\n     fps = fps.trimStart();\r\n     if (fps == \"Not Available\") {\r\n          if (msg.key.fromMe) {\r\n               var findedGame = game2.split(\"\/game\/\")[1].replace(\/-\/g, \" \")\r\n               findedGame = findedGame.replace(\/(^\\w{1})|(\\s+\\w{1})\/g, letter => letter.toUpperCase());\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_This game has not been supported!_\\n\\n*Game:* \" + findedGame, edit: msg.key });\r\n          } else {\r\n               return await sock.sendMessage(msg.key.remoteJid, { text: \"_This game has not been supported!_\\n\\n*Game:* \" + findedGame, edit: publicMessage.key });\r\n          }\r\n     }\r\n\r\n     var findedGame = game2.split(\"\/game\/\")[1].replace(\/-\/g, \" \")\r\n     findedGame = findedGame.replace(\/(^\\w{1})|(\\s+\\w{1})\/g, letter => letter.toUpperCase());\r\n\r\n     fps = \"*\" + findedGame + \"*\\n\\n\" + \"*CPU ::* \" + cpu2.cpu + \"\\n*GPU:* \" + gpu22.gpu + \"\\n*RAM:* \" + configs[3] + \" GB\\n\\n\" + fps;\r\n\r\n     if (msg.key.fromMe) {\r\n          return await sock.sendMessage(msg.key.remoteJid, { text: fps, edit: msg.key });\r\n     } else {\r\n          return await sock.sendMessage(msg.key.remoteJid, { text: fps, edit: publicMessage.key });\r\n     }\r\n});",
        "videoPath": ".\/src\/gamefps.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "IMDB Search",
        "keywords": [
            "film",
            "search",
            "imdb",
            "movie",
            "tv",
            "series",
            "imdb search"
        ],
        "usage": "menu imdb",
        "pluginId": "imdb",
        "description": "Searches for a movie on IMDb.",
        "downloads": 6,
        "pluginVersion": "1.0.1",
        "pluginFileName": "imdb.js",
        "context": "const axios = require('axios');\r\nconst cheerio = require('cheerio');\r\nconst fs = require('fs');\r\n\r\n\/**\r\n * Searches for a movie on IMDb and returns its details.\r\n * @param {string} movieName - The name of the movie to search for.\r\n * @returns {Promise<{status: number, title: string, description: string, rating: string, url: string, director: string, writer: string, actors: string[], stars: string[], thumbnail: string, release_date: string, length: string}>} - A Promise that resolves to an object with the movie details, or rejects with an error.\r\n *\/\r\nasync function searchMovie(movieName) {\r\n    let response = await axios.get(\"https:\/\/v3.sg.media-imdb.com\/suggestion\/x\/\" + encodeURIComponent(movieName) + \".json?includeVideos=1\");\r\n    const jsonData = response.data;\r\n    if (!jsonData.d || jsonData.d.length === 0) {\r\n        return { status: 404 };\r\n    }\r\n    const movies = jsonData.d.filter((movie) => movie.qid === \"movie\" || movie.qid === \"tvMovie\");\r\n    if (movies.length === 0) {\r\n        return { status: 404 };\r\n    }\r\n    const url = \"https:\/\/www.imdb.com\/title\/\" + movies[0].id + \"\/\";\r\n    let moviePageResponse = await axios.get(url, {\r\n        headers: {\r\n            \"User-Agent\": \"Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/237.84.2.178 Safari\/537.36\",\r\n            Accept: \"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/avif,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.7\"\r\n        }\r\n    });\r\n    const moviePage = moviePageResponse.data;\r\n    const $ = cheerio.load(moviePage);\r\n    const movieTitle = $(\".hero__primary-text\").text().trim();\r\n    const movieRating = $(\".sc-d541859f-1.imUuxf\").first().text().trim() + \"\/10\";\r\n    const director = $(\".ipc-metadata-list-item__list-content-item.ipc-metadata-list-item__list-content-item--link\").first().text().trim();\r\n    const writer = $(\".ipc-metadata-list-item__list-content-item.ipc-metadata-list-item__list-content-item--link\").eq(1).text().trim();\r\n    const description = $(\".sc-42125d72-1\").text().trim();\r\n\r\n    const actorNames = [];\r\n    $('section[data-testid=\"title-cast\"].celwidget').find('.sc-cd7dc4b7-1.kVdWAO').each((i, element) => {\r\n        actorNames.push($(element).text().trim());\r\n    });\r\n\r\n    let aa2 = \"\";\r\n    const parts = moviePage.split('<li role=\"presentation\" class=\"ipc-metadata-list__item ipc-metadata-list-item--link\" data-testid=\"title-pc-principal-credit\">');\r\n    for (const part of parts) {\r\n        if (part.includes(\"Stars\")) {\r\n            aa2 = part.split('<a class=\"ipc-metadata-list-item__icon-link\"')[0];\r\n            break;\r\n        }\r\n    }\r\n    const $2 = cheerio.load(aa2);\r\n    const stars = [];\r\n    $2('ul.ipc-inline-list li a').each((index, element) => {\r\n        stars.push($2(element).text().trim());\r\n    });\r\n\r\n    const thumbnail = movies[0]?.i?.imageUrl || \"\";\r\n    const rDate = [];\r\n    $('.ipc-link.ipc-link--baseAlt.ipc-link--inherit-color').each((i, element) => {\r\n        const text = $(element).text().trim();\r\n        if (\/^\\d+$\/.test(text)) {\r\n            rDate.push(text);\r\n        }\r\n    });\r\n\r\n    let length = \"\";\r\n    $('.ipc-inline-list__item').each((i, element) => {\r\n        const text = $(element).text().trim();\r\n        if (\/^\\d+h \\d+m$\/.test(text)) {\r\n            length = text;\r\n            return false;\r\n        }\r\n    });\r\n\r\n    return {\r\n        status: 200,\r\n        title: movieTitle,\r\n        description,\r\n        rating: movieRating,\r\n        url: url,\r\n        director: director,\r\n        writer: writer,\r\n        actors: actorNames,\r\n        stars: stars,\r\n        thumbnail: thumbnail,\r\n        release_date: rDate[0],\r\n        length: length\r\n    };\r\n}\r\n\r\naddCommand({ pattern: \"^imdb ?(.*)$\", access: \"all\", desc: \"_Searches for a movie on IMDb._\", pluginVersion: \"1.0.1\", pluginId: \"imdb\" }, async (msg, match, sock, rawMessage) => {\r\n\r\n    const movieName = match[1];\r\n    if (!movieName) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please provide a movie name to search for._\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please provide a movie name to search for._\"}, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: \"_Searching for movie..._\", edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: \"_Searching for movie..._\"}, { quoted: rawMessage.messages[0] });\r\n    }\r\n\r\n    var imdbData;\r\n    try {\r\n        imdbData = await searchMovie(movieName);\r\n    } catch {\r\n        imdbData = { status: 404 };\r\n    }\r\n\r\n    if (imdbData.status === 404) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Movie not found._\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Movie not found._\", edit: publicMessage.key });\r\n        }\r\n    }\r\n\r\n    var buffer = await global.downloadarraybuffer(imdbData.thumbnail);\r\n    var mediaPath = \".\/src\/imdb_\" + Math.floor(Math.random() * 20) + \".jpg\";\r\n    fs.writeFileSync(mediaPath, buffer);\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, {delete: msg.key});\r\n        await sock.sendMessage(msg.key.remoteJid, {\r\n            image: { url: mediaPath },\r\n            caption: \"_üìΩÔ∏è Movie Details üìΩÔ∏è_\\n\\n\" + \"*Title::* _\" + imdbData.title + \"_\\n*Description::* _\" + imdbData.description + \"_\\n*Rating::* _\" + imdbData.rating + \"_\\n*Director::* _\" + imdbData.director + \"_\\n*Writer::* _\" + imdbData.writer + \"_\\n*Actors::* _\" + imdbData.actors.join(\", \") + \"_\\n*Stars::* _\" + imdbData.stars.join(\", \") + \"_\\n*Release Date::* _\" + imdbData.release_date + \"_\\n*Length::* _\" + imdbData.length + \"_\\n*URL::* _\" + imdbData.url + \"_\",\r\n        });\r\n    } else {\r\n        await sock.sendMessage(msg.key.remoteJid, {delete: publicMessage.key});\r\n        await sock.sendMessage(msg.key.remoteJid, {\r\n            image: { url: mediaPath },\r\n            caption: \"_üìΩÔ∏è Movie Details üìΩÔ∏è_\\n\\n\" + \"*Title::* _\" + imdbData.title + \"_\\n*Description::* _\" + imdbData.description + \"_\\n*Rating::* _\" + imdbData.rating + \"_\\n*Director::* _\" + imdbData.director + \"_\\n*Writer::* _\" + imdbData.writer + \"_\\n*Actors::* _\" + imdbData.actors.join(\", \") + \"_\\n*Stars::* _\" + imdbData.stars.join(\", \") + \"_\\n*Release Date::* _\" + imdbData.release_date + \"_\\n*Length::* _\" + imdbData.length + \"_\\n*URL::* _\" + imdbData.url + \"_\",\r\n        })\r\n    }\r\n    try {fs.unlinkSync(mediaPath);} catch {}\r\n})",
        "videoPath": ".\/src\/imdb.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "Screenshot",
        "keywords": [
            "ss",
            "screenshot",
            "screen",
            "screen capture",
            "capture",
            "image",
            "image screenshot",
            "screenshot image",
            "ss image"
        ],
        "usage": "menu ss",
        "pluginId": "screenshot",
        "description": "Take a screenshot of a website.",
        "downloads": 2,
        "pluginVersion": "1.0.2",
        "pluginFileName": "screenshot.js",
        "context": "const axios = require('axios');\r\nconst fs = require('fs');\r\n\r\n\/**\r\n * Take a screenshot of a website.\r\n * @param {string} url - The URL of the website to take a screenshot of.\r\n * @returns {Promise<ArrayBuffer>} - A Promise that resolves to the screenshot as an ArrayBuffer.\r\n *\/\r\nasync function takeScreenshot(url) {\r\n    const response = await axios.get(\"https:\/\/api.pikwy.com\/?tkn=125&d=3000&u=\" + encodeURIComponent(url) + \"&fs=1&w=1280&h=1200&s=100&z=100&f=jpg&rt=jweb\");\r\n    const imgRes = await axios.get(response.data.iurl, { responseType: 'arraybuffer' });\r\n    return imgRes.data;\r\n}\r\n\r\naddCommand({ pattern: '^ss ?(.*)', access: 'all', desc: 'Take a screenshot of a website.', pluginVersion: \"1.0.2\", pluginId: \"screenshot\"}, async (msg, match, sock, rawMessage) => {\r\n    const url = match[1];\r\n    if (!url) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a URL to take a screenshot of._', edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a URL to take a screenshot of._'}, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: '_‚è≥ Taking screenshot.._', edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: '_‚è≥ Taking screenshot.._'}, { quoted: rawMessage.messages[0] });\r\n    }\r\n\r\n    try {\r\n        const screenshot = await takeScreenshot(url);\r\n        var mediaPath = '.\/src\/ss' + Math.floor(Math.random() * 20) + '.png';\r\n        fs.writeFileSync(mediaPath, screenshot);\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { delete: msg.key });\r\n            await sock.sendMessage(msg.key.remoteJid, { image: { url: mediaPath }, caption: '_üì∏ Screenshot taken!_' });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { delete: publicMessage.key });\r\n            await sock.sendMessage(msg.key.remoteJid, { image: { url: mediaPath }, caption: '_üì∏ Screenshot taken!_' });\r\n        }\r\n        try { fs.unlinkSync(mediaPath) } catch {}\r\n    } catch (error) {\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Failed to take screenshot. Please try again later._', edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Failed to take screenshot. Please try again later._', edit: publicMessage.key });\r\n        }\r\n        return;\r\n    }\r\n});",
        "videoPath": ".\/src\/screenshot.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "Wallpaper Search",
        "keywords": [
            "wallpaper",
            "wallpaper search",
            "image",
            "image search",
            "4k",
            "4k wallpaper",
            "4k image",
            "random wallpaper"
        ],
        "usage": "menu wp",
        "pluginId": "wallpaper",
        "description": "Search for a wallpaper on the internet.",
        "downloads": 2,
        "pluginVersion": "1.0.0",
        "pluginFileName": "wallpaper.js",
        "context": "const axios = require(\"axios\");\r\nconst cheerio = require(\"cheerio\");\r\nconst fs = require(\"fs\");\r\n\r\n\/**\r\n * Downloads wallpapers from wallhaven.cc\r\n * @param {string} query - the search query\r\n * @param {string} [ratio] - the aspect ratio of the wallpapers to retrieve. Available values are \"mobile\" and \"desktop\". If not provided, all wallpapers will be retrieved.\r\n * @returns {Promise<string[]>} An array of URLs of the wallpapers.\r\n *\/\r\nasync function getWallpaper(query, ratio = false) {\r\n\r\n    const url = `https:\/\/wallhaven.cc\/search?q=${encodeURIComponent(query)}` + (ratio ? \"&ratios=\" + (ratio == \"mobile\" ? \"portrait\" : \"\") : \"\");\r\n    const response = await axios.get(url);\r\n    const $ = cheerio.load(response.data);\r\n    \r\n    var list = $(\".thumb-listing-page\").prop('outerHTML')\r\n\r\n    const dataSrcLinks = [];\r\n\r\n    $('img.lazyload').each((i, element) => {\r\n        const dataSrc = $(element).attr('data-src');\r\n        if (dataSrc) {\r\n            let fullRes = dataSrc.replace(\"th.wallhaven.cc\/small\", \"w.wallhaven.cc\/full\");\r\n            let lastSlashIndex = fullRes.lastIndexOf(\"\/\");\r\n            let filename = fullRes.substring(lastSlashIndex + 1);\r\n            fullRes = fullRes.substring(0, lastSlashIndex + 1) + \"wallhaven-\" + filename;\r\n            dataSrcLinks.push(fullRes);\r\n        }\r\n    });\r\n\r\n    return dataSrcLinks;\r\n}\r\n\r\n\/**\r\n * Downloads wallpapers from wallspic.com\r\n * @param {string} query - the search query\r\n * @param {string} [ratio] - the aspect ratio of the wallpapers to retrieve. Available values are \"mobile\" and \"desktop\". If not provided, all wallpapers will be retrieved.\r\n * @returns {Promise<string[]>} An array of URLs of the wallpapers.\r\n *\/\r\nasync function getWallpaperv2(query, ratio = false) {\r\n    var url = \"https:\/\/wallspic.com\/search\/\" + encodeURIComponent(query) + (ratio ? ratio ==  \"mobile\" ? \"\/for_mobile\" : \"\" : \"\");\r\n    var response = await axios.get(url);\r\n    response = response.data;\r\n\r\n    if (!response.includes('<script type=\"application\/ld+json\">')) {\r\n        return [];\r\n    }\r\n\r\n    const $ = cheerio.load(response);\r\n\r\n    const scriptEtiketleri = $('script[type=\"application\/ld+json\"]');\r\n    const ucuncuScriptEtiketi = scriptEtiketleri.eq(2);\r\n    const jsonData = JSON.parse(ucuncuScriptEtiketi.text());\r\n\r\n    var urls = [];\r\n    if (Array.isArray(jsonData)) {\r\n        jsonData.forEach(item => {\r\n            if (item.contentUrl) {\r\n                urls.push(item.contentUrl);\r\n            }\r\n        });\r\n    }\r\n\r\n    return urls;\r\n}\r\n\r\naddCommand({ pattern: \"^wp ?(.*)\", access: \"all\", desc: \"_Get wallpapers of a query._\", pluginVersion: \"1.0.0\", pluginId: \"wallpaper\"}, async (msg, match, sock, rawMessage) => {\r\n    var query = match[1];\r\n    if (!query) {\r\n        var example = \"\\n_Example:_ ```\" + global.handlers[0] + \"wp <query> <model> <ratio>```\\n\\n_Models: <-v1 || -v2>_\\n_Ratios: <-mobile>_\\n\\n_V2 provides high resolution wallpapers, V1 provides more type of wallpapers!_\";\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please provide a query to search for._\" + example, edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå Please provide a query to search for._\" + example}, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    var model = query.includes(\"-v2\") ? \"-v2\" : \"-v1\";\r\n    var ratio = query.includes(\"-mobile\") ? \"mobile\" : false;\r\n    query = query.replace(\"-v2\", \"\").replace(\"-v1\", \"\").replace(\"-mobile\", \"\")\r\n    query = query.trimEnd().trimStart();\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: \"_üñºÔ∏è Searching for wallpapers..._\", edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: \"_üñºÔ∏è Searching for wallpapers..._\" }, { quoted: rawMessage.messages[0] });\r\n    }\r\n\r\n    var images;\r\n\r\n    if (model == \"-v2\") {\r\n        images = await getWallpaperv2(query, ratio);\r\n    } else {\r\n        images = await getWallpaper(query, ratio);\r\n    }\r\n\r\n    if (images.length == 0) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå No wallpapers found._\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: \"_‚ùå No wallpapers found._\", edit: publicMessage.key });\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Sends a random image from the list of images to the given JID\r\n     * @returns {Promise<string>} The path to the saved image\r\n     *\/\r\n    async function sendRandomImage() {\r\n        var randomImage = images[Math.floor(Math.random() * images.length)];\r\n        var mediaPath = \".\/src\/wallpaper_\" + Math.floor(Math.random() * 20) + \".jpg\";\r\n        try {\r\n            var image = await axios.get(randomImage, { responseType: 'arraybuffer' });\r\n        } catch {\r\n            return await sendRandomImage();\r\n        }\r\n\r\n        fs.writeFileSync(mediaPath, image.data);\r\n        var caption = \"_üñºÔ∏è Wallpaper (\" + query + \")_\\n\" + \"_Model ::_ \" + model.toUpperCase().replace(\"-\", \"\") + \"\\n_Ratio ::_ \" + (ratio ? \"Mobile\" : \"Desktop\");\r\n        await sock.sendMessage(msg.key.remoteJid, { delete: msg.key.fromMe ? msg.key : publicMessage.key });\r\n        await sock.sendMessage(msg.key.remoteJid, { image: { url: mediaPath}, caption: caption });\r\n        return mediaPath\r\n    }\r\n\r\n    var getFilee = await sendRandomImage();\r\n    try { fs.unlinkSync(getFilee); } catch { }\r\n    return;\r\n})",
        "videoPath": ".\/src\/wallpaper.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "URL Shortener",
        "keywords": [
            "url",
            "shorten",
            "shortener",
            "short url",
            "url shortener",
            "url short"
        ],
        "usage": "menu shorten",
        "pluginId": "shorten",
        "description": "A simple URL shortener.",
        "downloads": 1,
        "pluginVersion": "1.0.0",
        "pluginFileName": "shorten.js",
        "context": "const axios = require(\"axios\");\r\nconst formData = require(\"form-data\");\r\n\r\n\/**\r\n * Shorten a given URL using spoo.me\r\n * @param {string} url\r\n * @returns {string} shortened url\r\n *\/\r\nasync function shortenUrl(url) {\r\n    var form = new formData();\r\n    form.append(\"url\", url);\r\n    form.append(\"alias\", \"\");\r\n    form.append(\"password\", \"\");\r\n    form.append(\"max-clicks\", \"\");\r\n    form.append(\"block-bots\", \"on\");\r\n    var shorten = await axios({\r\n        url: \"https:\/\/spoo.me\/\",\r\n        method: \"POST\",\r\n        headers: form.getHeaders(),\r\n        data: form\r\n    })\r\n    return shorten.data.match(\/target=\"_blank\" id=\"short-url\">(.*?)<\\\/a>\/)[1]\r\n}\r\n\/**\r\n * Get the data of a shortened URL using spoo.me\r\n * @param {string} url the shortened URL\r\n * @returns {Object} the data of the shortened URL\r\n *\/\r\nasync function getData(url) {\r\n    \/\/ url: https:\/\/spoo.me\/1LaaYn\r\n    url = url.split(\".me\/\")[1]\r\n    var data = await axios({\r\n        url: \"https:\/\/spoo.me\/export\/\" + url + \"\/json?password=None\",\r\n        method: \"GET\",\r\n        responseType: \"json\"\r\n    })\r\n    return data.data\r\n}\r\n\r\naddCommand({ pattern: \"^shorten ?(.*)\", access: 'all', desc: '_Shorten a URL._', pluginVersion: \"1.0.0\", pluginId: \"shorten\"}, async (msg, match, sock, rawMessage) => {\r\n    const url = match[1];\r\n    if (!url) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a URL to shorten._', edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a URL to shorten._'}, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: '_Shortening URL..._', edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: '_Shortening URL..._'}, { quoted: rawMessage.messages[0] });\r\n    }\r\n    try {\r\n        var shortUrl = await shortenUrl(url);\r\n        shortUrl = \"_Url Shortened: \" + shortUrl + \"_\";\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: shortUrl, edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: shortUrl , edit: publicMessage.key });\r\n        }\r\n    } catch (error) {\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå An error occurred while shortening the URL._', edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå An error occurred while shortening the URL._', edit: publicMessage.key });\r\n        }\r\n    }\r\n    return;\r\n});\r\n\r\naddCommand({ pattern: \"^shortendata ?(.*)\", access: 'all', desc: '_Get data of a short url._', pluginVersion: \"1.0.0\", pluginId: \"shorten\"}, async (msg, match, sock, rawMessage) => {\r\n    const url = match[1];\r\n    if (!url) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a short URL to shorten._', edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a short URL to shorten._'}, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(msg.key.remoteJid, { text: '_Getting data..._', edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(msg.key.remoteJid, { text: '_Getting data..._'}, { quoted: rawMessage.messages[0] });\r\n    }\r\n\r\n    try {\r\n        var shortUrl = await getData(url);\r\n        var mostUsedBrowser = Object.keys(shortUrl.browser).sort((a, b) => shortUrl.browser[b] - shortUrl.browser[a])[0];\r\n        var mostUsedOS = Object.keys(shortUrl.os_name).sort((a, b) => shortUrl.os_name[b] - shortUrl.os_name[a])[0];\r\n        var mostVisistedCountry = Object.keys(shortUrl.country).sort((a, b) => shortUrl.country[b] - shortUrl.country[a])[0];\r\n        \r\n        var text = \"_Short URL:_ \" + url + \"\\n\\n\" + \"_Total Clicks: \" + shortUrl[\"total-clicks\"] + \"_\\n\\n\" + \r\n        \"_Most Used Browser: \" + mostUsedBrowser + \" (\" + shortUrl.browser[mostUsedBrowser] + \" clicks)_\\n\" +\r\n        \"_Most Used OS: \" + mostUsedOS + \" (\" + shortUrl.os_name[mostUsedOS] + \" clicks)_\\n\" +\r\n        \"_Most Visited Country: \" + mostVisistedCountry + \" (\" + shortUrl.country[mostVisistedCountry] + \" clicks)_\\n\\n\" +\r\n        \"_Created At: \" + shortUrl[\"creation-date\"] + \"_\\n\" +\r\n        \"_Creation Time: \" + shortUrl[\"creation-time\"] + \"_\\n\" +\r\n        \"_Last Clicked At: \" + shortUrl[\"last-click\"] + \"_\\n\" +\r\n        \"_Avarage Click Rate: \" + shortUrl[\"average_weekly_clicks\"] + \" clicks\/week_\"\r\n\r\n\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: text, edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: text, edit: publicMessage.key });\r\n        }\r\n    } catch (error) {\r\n        console.log(error);\r\n        if (msg.key.fromMe) {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå An error occurred while getting the data._', edit: msg.key });\r\n        } else {\r\n            await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå An error occurred while getting the data._', edit: publicMessage.key });\r\n        }\r\n    }\r\n    return;\r\n})",
        "videoPath": ".\/src\/shorten.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "This X Does Not Exist",
        "keywords": [
            "ai",
            "gan",
            "thisx",
            "thisxdoesnotexist",
            "this x does not exist",
            "face",
            "house",
            "word"
        ],
        "usage": "menu thisx",
        "pluginId": "thisx",
        "description": "An implementation of the This X Does Not Exist.",
        "downloads": 2,
        "pluginVersion": "1.0.0",
        "pluginFileName": "thisx.js",
        "context": "const axios = require('axios');\r\nconst fs = require('fs');\r\nconst ffmpeg = require('fluent-ffmpeg');\r\nconst ffmpegPath = require('@ffmpeg-installer\/ffmpeg').path;\r\nffmpeg.setFfmpegPath(ffmpegPath);\r\n\r\nasync function thisPersonDoesNotExist() {\r\n    const response = await axios.get(\"https:\/\/thispersondoesnotexist.com\/\",  { responseType: \"arraybuffer\" });;\r\n    return response.data;\r\n}\r\n\r\nasync function thisHouseDoesNotExist(out) {\r\n    var response = await axios.get(\"https:\/\/thishousedoesnotexist.org\/\");\r\n    response = response.data;\r\n    response = \"https:\/\/thishousedoesnotexist.org\" + response.split('<img class=\"img-house\" src=\"')[1].split('\"')[0];\r\n    const response2 = await axios.get(response, { responseType: \"arraybuffer\" });\r\n    fs.writeFileSync(out, response2.data);\r\n    return out\r\n}\r\n\r\nasync function thisWordDoesNotExist() {\r\n    var response = await axios.get(\"https:\/\/www.thisworddoesnotexist.com\/\");\r\n    response = response.data;\r\n    return {\r\n        word: response.split('<div id=\"definition-word\" class=\"word\">')[1].split('<\/div>')[0].split(\" \").map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(\" \"),\r\n        definition: response.split('<div id=\"definition-definition\" class=\"definition\">')[1].split('<\/div>')[0].trim().charAt(0).toUpperCase() + response.split('<div id=\"definition-definition\" class=\"definition\">')[1].split('<\/div>')[0].trim().slice(1),\r\n    }\r\n}\r\n\r\naddCommand({ pattern: \"^thisx ?(.*)\", access: \"all\", desc: \"_An implementation of the This X Dont Exist_\", pluginVersion: \"1.0.0\", pluginId: \"thisx\"}, async (msg, match, sock, rawMessage) => {\r\n    var command = match[1];\r\n    if (!command) {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a command._\\n_Example::_ ```' + global.handlers[0] + \"thisx <person, house, word>```\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a command._\\n_Example::_ ```' + global.handlers[0] + \"thisx <person, house, word>```\"}, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n\r\n    command = command.toLowerCase().trim()\r\n    var housePath = \".\/src\/this_house_does_not_exist\" + Math.floor(Math.random() * 20) + \".png\"\r\n    var housePath2 = \".\/src\/this_house_does_not_exist\" + Math.floor(Math.random() * 200) + \".png\"\r\n    var personPath = \".\/src\/this_person_does_not_exist\" + Math.floor(Math.random() * 20) + \".png\"\r\n\r\n    if (command == \"person\") {\r\n        var person = await thisPersonDoesNotExist();\r\n        var personPath = \".\/src\/this_person_does_not_exist\" + Math.floor(Math.random() * 20) + \".png\"\r\n        fs.writeFileSync(personPath, person);\r\n        await sock.sendMessage(msg.key.remoteJid, {delete: msg.key})\r\n        await sock.sendMessage(msg.key.remoteJid, { image: {url: personPath}, caption: \"_This person does not exist_\" });\r\n        try { fs.unlinkSync(personPath); } catch (err) { }\r\n        return;\r\n    } else if (command == \"house\") {\r\n        var house = await thisHouseDoesNotExist(housePath);\r\n        ffmpeg(house).outputOptions('-vf', 'crop=in_w:in_h-50').save(housePath2).on('end', async () => {\r\n            await sock.sendMessage(msg.key.remoteJid, {delete: msg.key})\r\n            await sock.sendMessage(msg.key.remoteJid, { image: {url: housePath2}, caption: \"_This house does not exist_\" });\r\n            try { fs.unlinkSync(housePath); } catch (err) { }\r\n            try { fs.unlinkSync(housePath2); } catch (err) { }\r\n            return;\r\n        });\r\n       \r\n    } else if (command == \"word\") {\r\n        var word = await thisWordDoesNotExist();\r\n        await sock.sendMessage(msg.key.remoteJid, {delete: msg.key})\r\n        await sock.sendMessage(msg.key.remoteJid, { text: \"_Word:_ *\" + word.word + \"*\\n_Definition:_ *\" + word.definition + \"*\"});\r\n        return;\r\n    } else {\r\n        if (msg.key.fromMe) {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Invalid command._\\n_Example::_ ```' + global.handlers[0] + \"thisx <person, house, word>```\", edit: msg.key });\r\n        } else {\r\n            return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Invalid command._\\n_Example::_ ```' + global.handlers[0] + \"thisx <person, house, word>```\"}, { quoted: rawMessage.messages[0] });\r\n        }\r\n    }\r\n    \r\n})",
        "videoPath": ".\/src\/thisx.mp4"
    },
    {
        "author": "Phaticusthiccy",
        "pluginName": "Dicebear Avatars",
        "keywords": [
            "dicebear",
            "avatar",
            "avatar generator",
            "avatars",
            "dicebear avatars",
            "sticker",
            "sticker generator"
        ],
        "usage": "menu avatar",
        "pluginId": "dicebear",
        "description": "Generate a dicebear avatar.",
        "downloads": 2,
        "pluginVersion": "1.0.0",
        "pluginFileName": "dicebear.js",
        "context": "const fs = require('fs')\r\nconst ffmpeg = require('fluent-ffmpeg');\r\nconst ffmpegPath = require('@ffmpeg-installer\/ffmpeg').path;\r\nffmpeg.setFfmpegPath(ffmpegPath);\r\nconst axios = require('axios');\r\n\r\nvar randomAvatars = [\r\n    \"https:\/\/api.dicebear.com\/9.x\/adventurer\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/adventurer-neutral\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/avataaars-neutral\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/big-ears\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/big-ears-neutral\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/avataaars\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/big-smile\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/bottts\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/bottts-neutral\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/croodles\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/dylan\/png?seed=\",\r\n    \"https:\/\/api.dicebear.com\/9.x\/micah\/png?seed=\"\r\n]\r\n\r\naddCommand({ pattern: \"^avatar$\", access: \"all\", desc: \"_Get a random avatar from DiceBear._\", pluginVersion: \"1.0.0\", pluginId: \"dicebear\" }, async (msg, match, sock, rawMessage) => {\r\n    const groupId = msg.key.remoteJid;\r\n    const randomAvatar = randomAvatars[Math.floor(Math.random() * randomAvatars.length)];\r\n    const seed = Math.floor(Math.random() * Math.pow(2, 32));\r\n    const avatarUrl = randomAvatar + seed;\r\n\r\n    if (msg.key.fromMe) {\r\n        await sock.sendMessage(groupId, { text: \"_Generating Avatar..._\", edit: msg.key });\r\n    } else {\r\n        var publicMessage = await sock.sendMessage(groupId, { text: \"_Generating Avatar..._\" }, { quoted: rawMessage.messages[0] });\r\n    }\r\n\r\n    const response = await axios.get(avatarUrl, { responseType: 'arraybuffer' });\r\n    var mediaPath = \".\/src\/avatar\" + (Math.floor(Math.random() * 1000)) + \".png\";\r\n    var mediaPath2 = \".\/src\/avatar_converted\" + (Math.floor(Math.random() * 1000)) + \".png\";\r\n    fs.writeFileSync(mediaPath, response.data);\r\n\r\n    ffmpeg(mediaPath).outputOptions([\"-y\", \"-vcodec libwebp\"]).videoFilters('scale=1500:1500:flags=lanczos:force_original_aspect_ratio=decrease,format=rgba,pad=2000:2000:(ow-iw)\/2:(oh-ih)\/2:color=#00000000,setsar=1').save(mediaPath2).on('end', async () => {\r\n        await sock.sendMessage(groupId, { delete: msg.fromMe ? publicMessage.key : msg.key });\r\n        await sock.sendMessage(groupId, { sticker: { url: mediaPath2 } });\r\n        try {\r\n            fs.unlinkSync(mediaPath);\r\n            fs.unlinkSync(mediaPath2);\r\n        } catch { }\r\n    })\r\n})",
        "videoPath": ".\/src\/dicebear.mp4"
    },
    {
        "author": "Can",
        "pluginName": "ATTP",
        "keywords": [
            "attp",
            "ttp",
            "text to image",
            "text to photo",
            "sticker",
            "sticker generator",
            "image",
            "animation",
            "animated"
        ],
        "usage": "menu attp",
        "pluginId": "attp",
        "description": "Generate a animated sticker from text.",
        "downloads": 4,
        "pluginVersion": "1.0.1",
        "pluginFileName": "attp.js",
        "context": "const path = require('path');\r\nconst axios = require('axios');\r\nconst fs = require('fs');\r\nlet requestData = {\r\n  duration: 5,\r\n  fps: 4,\r\n  colors: [\r\n    [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), 255],\r\n    [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), 255],\r\n    [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), 255]\r\n  ],\r\n  text: undefined\r\n};\r\naddCommand({ pattern: \"^attp ?(.*)\", access: \"all\", desc: \"_Animated Text To Sticker._\", pluginVersion: \"1.0.1\", pluginId: \"attp\" }, async (msg, match, sock, rawMessage) => {\r\n  if (!match[1]) return await sock.sendMessage(msg.key.remoteJid, { text: '_‚ùå Please provide a text to convert to sticker._', ...(msg.key.fromMe ? { edit: msg.key } : {}) }, msg.key.fromMe ? {} : { quoted: rawMessage.messages[0] });\r\n\r\n  const dKey = await sock.sendMessage(msg.key.remoteJid, { text: '_‚è≥ Generating.._', ...(msg.key.fromMe ? { edit: msg.key } : {}) }, msg.key.fromMe ? {} : { quoted: rawMessage.messages[0] })\r\n\r\n  requestData.text = match[1];\r\n  let response;\r\n  try {\r\n    response = await axios.post('https:\/\/api.ic3zy.com.tr\/generate-video', requestData, {\r\n      headers: {\r\n        'Content-Type': 'application\/json',\r\n      },\r\n      timeout: 45000\r\n    });\r\n  } catch { response = 'err' };\r\n  const stickerPath = path.join(__dirname, '..', 'src', `attp${Math.floor(Math.random() * 10000)}.webp`);\r\n  if (response?.data?.success != true && response == 'err') return await sock.sendMessage(msg.key.remoteJid, { text: '‚ùå _An error occurred during production. The server may be down or something else, it will be resolved soon._', ...(msg.key.fromMe ? { edit: msg.key } : {}) }, msg.key.fromMe ? {} : { quoted: rawMessage.messages[0] });\r\n  await downloadVideo(response.data.videoUrl, stickerPath);\r\n  await sock.sendMessage(msg.key.remoteJid, { delete: dKey.key });\r\n  await sock.sendMessage(msg.key.remoteJid, { sticker: { url: stickerPath } });\r\n  try { fs.unlinkSync(stickerPath); } catch { }\r\n  return;\r\n});\r\n\r\nasync function downloadVideo(url, outputPath) {\r\n  const writer = fs.createWriteStream(outputPath);\r\n\r\n  const response = await axios({\r\n    url,\r\n    method: 'GET',\r\n    responseType: 'stream',\r\n  });\r\n\r\n  response.data.pipe(writer);\r\n\r\n  return new Promise((resolve, reject) => {\r\n    writer.on('finish', resolve);\r\n    writer.on('error', reject);\r\n  });\r\n}",
        "videoPath": ".\/src\/attp.mp4"
    }
]